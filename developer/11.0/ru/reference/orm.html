<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml" lang="Русский">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css?family=Work+Sans:500,600" rel="stylesheet">
  
    <title>ORM API &mdash; Перевод на русский язык документации Odoo 11.0</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/patchqueue.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/patchqueue.js"></script>
    <script type="text/javascript" src="../_static/jquery.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap.js"></script>
    <script type="text/javascript" src="../_static/doc.js"></script>
    <script type="text/javascript" src="../_static/jquery.noconflict.js"></script>
    <script type="text/javascript" src="https://yastatic.net/es5-shims/0.0.2/es5-shims.min.js"></script>
    <script type="text/javascript" src="https://yastatic.net/share2/share.js"></script>
    <link rel="top" title="Перевод на русский язык документации Odoo 11.0" href="../index.html" />
    <link rel="up" title="Справочные материалы" href="../reference.html" />
    <link rel="next" title="Файлы с данными" href="data.html" />
    <link rel="prev" title="Справочные материалы" href="../reference.html" /> 
  </head>
  <body role="document"><header class="o_main_header o_has_sub_nav o_inverted ">
  <div class="o_main_header_main">
    <a class="pull-left o_logo" href="/"></a>
    <a href="#" class="o_mobile_menu_toggle visible-xs-block pull-right">
      <span class="sr-only">Toggle navigation</span>
      <span class="mdi-navigation-menu"></span>
    </a>
    <ul class="o_primary_nav">
      <li><a href="/">Документация</a></li>
    </ul>
  </div>
  <nav class="navbar o_sub_nav">
    <div class="container">
      <div class="navbar-header visible-xs">
          <button type="button" class="navbar-toggle collapsed text-left btn-block" data-toggle="collapse" data-target="#o_sub-menu" aria-expanded="false">
            Меню
            <span class="mdi-hardware-keyboard-arrow-down pull-right"></span>
          </button>
      </div>

      <div class="collapse navbar-collapse" id="o_sub-menu">
        <ol class="o_breadcrumb breadcrumb nav navbar-left">
            
            
            





    
        
            <li><a href="../index.html">Документация  (11.0)</a></li>
        
    
    <li class="active"><a href="#">ORM API</a></li>

            
        </ol>

        <ul class="navbar-nav navbar-right nav o_sub_nav_actions">
          
            <li class="divider"></li>
          

          
          
<li class="languages dropdown">
    <a class="dropdown-toggle" href="#" data-toggle="dropdown">
        Русский
    </a>
    <ul class="dropdown-menu" role="menu">
        
            <li><a href="/developer/11.0/en/reference/orm.html">English</a></li>
        
    </ul>
</li>



<li class="versions dropdown">
    <a class="dropdown-toggle" href="#" data-toggle="dropdown">
        11.0
    </a>
    <ul class="dropdown-menu" role="menu">
        
            <li><a href="/developer/8.0/ru/reference/orm.html">8.0</a></li>
        
            <li><a href="/developer/9.0/ru/reference/orm.html">9.0</a></li>
        
            <li><a href="/developer/10.0/ru/reference/orm.html">10.0</a></li>
        
    </ul>
</li>

          
        </ul>

        <ul class="nav navbar-nav navbar-right">
          
            <li class="divider"></li>
          

          
          

<li><a href="/user/11.0/ru/">Пользователю</a></li>
<li><a href="/developer/11.0/ru/">Разработчику</a></li>
<li><a href="/developer/11.0/ru/api_integration.html">API</a></li>
<li><a href="/developer/11.0/ru/setup/install.html">Установка</a></li>
<li><a href="/developer/11.0/ru/python3.html">Python 3</a></li>
          

          
            <li class="divider"></li>
          
        </ul>
      </div>
    </div>
  </nav>
</header><div id="wrap" class="">
    
    
    
    <figure class="card top has_banner">
      <span class="card-img" style="background-image: url('../_static/banners/orm_api.jpg');"></span>
      <div class="container text-center">
        <h1> ORM API - Odoo 11.0 </h1>
      </div>
    </figure>
    
    
    
      <main class="container ">
        
        <div class="o_content row">
          
          <aside>
            <div class="navbar-aside text-center">
              <ul class="list-group text-left nav"><li class="list-group-item"><a href="#recordsets" class="ripple internal reference">Наборы записей</a><ul ><li class="list-group-item"><a href="#field-access" class="ripple internal reference">Доступ к полям</a></li><li class="list-group-item"><a href="#record-cache-and-prefetching" class="ripple internal reference">Запись кеша и предварительная выборка</a></li><li class="list-group-item"><a href="#set-operations" class="ripple internal reference">Операции над НЗ</a></li><li class="list-group-item"><a href="#other-recordset-operations" class="ripple internal reference">Другие операции с НЗ</a></li></ul></li><li class="list-group-item"><a href="#environment" class="ripple internal reference">Окружение</a><ul ><li class="list-group-item"><a href="#altering-the-environment" class="ripple internal reference">Изменение окружения</a></li></ul></li><li class="list-group-item"><a href="#common-orm-methods" class="ripple internal reference">Базовые методы ORM</a></li><li class="list-group-item"><a href="#creating-models" class="ripple internal reference">Создание моделей данных</a><ul ><li class="list-group-item"><a href="#computed-fields" class="ripple internal reference">Вычисляемые поля</a><ul ><li class="list-group-item"><a href="#related-fields" class="ripple internal reference">Реляционные поля</a></li></ul></li><li class="list-group-item"><a href="#onchange-updating-ui-on-the-fly" class="ripple internal reference">оnchange: обновление интерфейса на лету</a></li><li class="list-group-item"><a href="#low-level-sql" class="ripple internal reference">Использование SQL</a></li></ul></li><li class="list-group-item"><a href="#compatibility-between-new-api-and-old-api" class="ripple internal reference">Совместимость между новым API и старым API</a></li><li class="list-group-item"><a href="#model-reference" class="ripple internal reference">Ссылки на модели данных</a></li><li class="list-group-item"><a href="#module-odoo.api" class="ripple internal reference">Декораторы методов</a></li><li class="list-group-item"><a href="#fields" class="ripple internal reference">Поля</a><ul ><li class="list-group-item"><a href="#basic-fields" class="ripple internal reference">Основные поля</a></li><li class="list-group-item"><a href="#relational-fields" class="ripple internal reference">Реляционные поля</a></li></ul></li><li class="list-group-item"><a href="#inheritance-and-extension" class="ripple internal reference">Наследование и расширение</a><ul ><li class="list-group-item"><a href="#classical-inheritance" class="ripple internal reference">Классическое наследование</a></li><li class="list-group-item"><a href="#extension" class="ripple internal reference">Расширение</a></li><li class="list-group-item"><a href="#delegation" class="ripple internal reference">Делегирование</a></li></ul></li><li class="list-group-item"><a href="#domains" class="ripple internal reference">Домены</a></li><li class="list-group-item"><a href="#porting-from-the-old-api-to-the-new-api" class="ripple internal reference">Портирование со старого API на новый API</a><ul ><li class="list-group-item"><a href="#automatic-bridging-of-old-api-methods" class="ripple internal reference">Автоматический проброс старых API-методов</a></li></ul></li></ul>
              
              <p class="gith-container"><a href="https://github.com/odoo/odoo/edit/11.0/doc/reference/orm.rst" class="gith-link">
                  Edit on GitHub
              </a></p>
              
            </div>
          </aside>
          
		  <div class="ya-share2" data-services="collections,vkontakte,facebook,odnoklassniki,moimir,gplus,twitter,linkedin,viber,whatsapp,skype,telegram"></div>
          <article class="doc-body ">
            
            
            
  <section id="orm-api"><i id="reference-orm"></i></section><section id="recordsets"><h2 >Наборы записей</h2><div class="versionadded"><p ><span class="versionmodified">Добавлено в версии 8.0: </span>На этой странице представлен новый API, добавленный в Odoo 8.0, который станет основным API разработки в будущем. Здесь также предоставлена информация о переносе или переходе со «старого API» версии 7 и более ранних, но вы не найдете здесь документации на старый API. Информацию о старом API ищите в соответствующих документах.</p></div><p >Взаимодействие с моделями данных и записями осуществляется с помощью Наборов Записей (НЗ) - отсортированного набора записей той же модели данных.</p><div role="alert" class="alert-warning alert"><h3 class="alert-title">Предупреждение</h3><p >Вопреки тому, что подразумевается под этим именем, в настоящее время в НЗ могут содержаться дубликаты. Это может измениться в будущем.</p></div><p >Методы, определенные для модели данных, выполняются над НЗ, а их <code >self</code> и представляет собой экземпляр НЗ:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;a.model&#39;</span>
    <span class="k">def</span> <span class="nf">a_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># self can be anywhere between 0 records and all records in the</span>
        <span class="c1"># database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_operation</span><span class="p">()</span>
</pre></div>
</div>
<p >Перебор НЗ приведет к созданию новых НЗ состоящих из <em >одной записи</em> (ОЗ), данный механизм можно сравнить с перебором строки Python который формирует строки из одного символа:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">print</span> <span class="bp">self</span> <span class="c1"># =&gt; a.model(1, 2, 3, 4, 5)</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">record</span> <span class="c1"># =&gt; a.model(1), then a.model(2), then a.model(3), ...</span>
</pre></div>
</div>
</section><section id="field-access"><h3 >Доступ к полям</h3><p >НЗ предоставляют интерфейс &quot;Active Record&quot;: поля моделей данных могут считываться и записываться непосредственно из записи, но только для ОЗ (НЗ состоящие из одиночной записи). Присвоение значения полю запускает обновление базы данных:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">name</span>
<span class="go">Example Name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">company_id</span><span class="o">.</span><span class="n">name</span>
<span class="go">Company Name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Bob&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
<span class="go">Bob</span>
</pre></div>
</div>
<p >Попытка прочитать или записать поле сразу в нескольких записях вызовет ошибку.</p><p >Доступ к реляционному полю(<a href="#odoo.fields.Many2one" class="internal reference" title="odoo.fields.Many2one"><code class="py xref py-class">Many2one</code></a>, <a href="#odoo.fields.One2many" class="internal reference" title="odoo.fields.One2many"><code class="py xref py-class">One2many</code></a>, <a href="#odoo.fields.Many2many" class="internal reference" title="odoo.fields.Many2many"><code class="py xref py-class">Many2many</code></a>) <em >всегда</em> возвращает НЗ, пустой если поле не задано.</p><div role="alert" class="alert-danger alert"><h3 class="alert-title">Опасно</h3><p >каждое присвоение полю какого либо значения запускает обновление базы данных, при одновременной установке нескольких полей или установке полей в нескольких записях (с тем же значением) используйте  <a href="#odoo.models.Model.write" class="internal alert-link reference" title="odoo.models.Model.write"><code class="py py-meth xref">write()</code></a>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># 3 * len(records) database updates</span>
<span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
    <span class="n">record</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">record</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">record</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># len(records) database updates</span>
<span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
    <span class="n">record</span><span class="o">.</span><span class="n">write</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>

<span class="c1"># 1 database update</span>
<span class="n">records</span><span class="o">.</span><span class="n">write</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
</pre></div>
</div>
</div></section><section id="record-cache-and-prefetching"><h3 >Запись кеша и предварительная выборка</h3><p >Odoo поддерживает кеш для полей записей, так что не каждый доступ к полям вызывает запрос базы данных, что ужасно сказывалось бы на производительности. Следующий пример запрашивает базу данных только для первого выражения:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">record</span><span class="o">.</span><span class="n">name</span>             <span class="c1"># first access reads value from database</span>
<span class="n">record</span><span class="o">.</span><span class="n">name</span>             <span class="c1"># second access gets value from cache</span>
</pre></div>
</div>
<p >Чтобы не считывать одно поле из одной записи за раз, Odoo <em >выполняет предварительную выборку</em> записей и полей, следуя некоторым эвристикам, чтобы получить хорошую производительность. Как только поле должно быть прочитано в данной записи, ORM фактически считывает это поле в большем НЗ и сохраняет возвращаемые значения в кеше для последующего использования. Унаследованный НЗ обычно представляет собой ИЗ, из которого запись выбирается путем перебора. Более того, все простые хранимые поля (boolean, integer, float, char, text, date, datetime, selection, many2one) извлекаются целиком; Они соответствуют столбцам таблицы модели данных и эффективно извлекаются в одном запросе.</p><p >Рассмотрим следующий пример, где <code >partners</code> - набор записей из 1000 записей. Без предварительной выборки цикл будет выполнять 2000 запросов к базе данных. При предварительной выборке выполняется только один запрос:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">partner</span> <span class="ow">in</span> <span class="n">partners</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">partner</span><span class="o">.</span><span class="n">name</span>          <span class="c1"># first pass prefetches &#39;name&#39; and &#39;lang&#39;</span>
                                <span class="c1"># (and other fields) on all &#39;partners&#39;</span>
    <span class="nb">print</span> <span class="n">partner</span><span class="o">.</span><span class="n">lang</span>
</pre></div>
</div>
<p >Предварительная выборка также работает на <em >вторичных записях</em>: при чтении значений реляционных полей (которые являются записями) подписываются на будущую предварительную выборку. При обращении к одной из этих вторичных записей происходит предварительная выборка всех вторичных записей из одной и той же модели данных. В следующем примере генерируются только два запроса: один для партнеров и один для стран:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">countries</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">partner</span> <span class="ow">in</span> <span class="n">partners</span><span class="p">:</span>
    <span class="n">country</span> <span class="o">=</span> <span class="n">partner</span><span class="o">.</span><span class="n">country_id</span>        <span class="c1"># first pass prefetches all partners</span>
    <span class="n">countries</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">country</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>         <span class="c1"># first pass prefetches all countries</span>
</pre></div>
</div>
</section><section id="set-operations"><h3 >Операции над НЗ</h3><p >НЗ не изменяемы, но наборы одной и той же модели могут комбинироваться с использованием различных операторов для НЗ, возвращая новые НЗ. Данные операторы <em >не сохраняют</em> порядок сортировки записей внутри НЗ.</p><ul ><li ><p ><code >record in set</code> возвращает <code >запись</code> (которая должна быть набором из 1 элемента) если таковая присутствует присутствует в НЗ <code >set</code>. <code >record not in set</code> - это обратная операция</p></li><li ><p ><code >set1 &lt;= set2</code> и <code >set1 &lt; set2</code> возвращает НЗ <code >set1</code> если он входит НЗ <code >set2</code> (resp. strict)</p></li><li ><p ><code >set1 &gt;= set2</code> and <code >set1 &gt; set2</code> возвращает НЗ <code >set1</code> если он включает в себя НЗ <code >set2</code> (resp. strict)</p></li><li ><p ><code >set1 | set2</code> возвращает объединение двух НЗ, новый НЗ содержит все записи, имеющиеся каждом источнике</p></li><li ><p ><code >set1 &amp; set2</code> возвращает пересечение двух НЗ, новый НЗ содержит только те записи которые содержатся одновременно в обоих источниках</p></li><li ><p ><code >set1 - set2</code> возвращает новый НЗ, содержащий только записи НЗ <code >set1</code>, которые <em >не</em> входят в НЗ <code >set2</code></p></li></ul></section><section id="other-recordset-operations"><h3 >Другие операции с НЗ</h3><p >НЗ это итерируемый объект, поэтому обычные инструменты Python доступны для работы с ним (<a href="https://docs.python.org/3/library/functions.html#map" class="external reference" title="(в Python v3.7)"><code >map()</code></a>, <a href="https://docs.python.org/3/library/functions.html#sorted" class="external reference" title="(в Python v3.7)"><code >sorted()</code></a>, <code class="py xref py-func">itertools.ifilter</code>, ...) однако они возвращают либо <a href="https://docs.python.org/3/library/stdtypes.html#list" class="external reference" title="(в Python v3.7)"><code >list</code></a> или <a href="https://docs.python.org/3/glossary.html#term-iterator" class="external reference" title="(в Python v3.7)"><span >iterator</span></a>, удаляя возможность вызывать методы для возвращенных результатов, или использовать операции НЗ.</p><p >Поэтому НЗ предоставляют такие операции, которые возвращают объекты НЗ (когда это возможно):</p><dl ><dt ><a href="#odoo.models.Model.filtered" class="internal reference" title="odoo.models.Model.filtered"><code class="py py-meth xref">filtered()</code></a></dt><dd ><p >Возвращает НЗ, содержащий только записи, удовлетворяющие предоставленной предикатной функции. Предикат может также быть строкой для отфильтрованный по полю, являющемуся истинным или ложным:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># only keep records whose company is the current user&#39;s</span>
<span class="n">records</span><span class="o">.</span><span class="n">filtered</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">company_id</span> <span class="o">==</span> <span class="n">user</span><span class="o">.</span><span class="n">company_id</span><span class="p">)</span>

<span class="c1"># only keep records whose partner is a company</span>
<span class="n">records</span><span class="o">.</span><span class="n">filtered</span><span class="p">(</span><span class="s2">&quot;partner_id.is_company&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd><dt ><a href="#odoo.models.Model.sorted" class="internal reference" title="odoo.models.Model.sorted"><code class="py py-meth xref">sorted()</code></a></dt><dd ><p >Возвращает НЗ, отсортированный по предоставленной ключевой функции. Если ключ не указан, используется порядок сортировки установленный для модели данных по умолчанию:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># sort records by name</span>
<span class="n">records</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</dd><dt ><a href="#odoo.models.Model.mapped" class="internal reference" title="odoo.models.Model.mapped"><code class="py py-meth xref">mapped()</code></a></dt><dd ><p >Применяет предоставленную функцию к каждой записи в НЗ, возвращает НЗ, если результаты являются НЗ:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># returns a list of summing two fields for each record in the set</span>
<span class="n">records</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">field1</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">field2</span><span class="p">)</span>
</pre></div>
</div>
<p >Предоставленная функция может быть строкой для получения значений полей:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># returns a list of names</span>
<span class="n">records</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>

<span class="c1"># returns a recordset of partners</span>
<span class="n">record</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="s1">&#39;partner_id&#39;</span><span class="p">)</span>

<span class="c1"># returns the union of all partner banks, with duplicates removed</span>
<span class="n">record</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="s1">&#39;partner_id.bank_ids&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl></section><section id="environment"><h2 >Окружение</h2><p >Класс <code class="py xref py-class">Environment</code> хранит различные контекстные данные, используемые ORM: курсор базы данных (формирования запросов к базе данных), текущий пользователь (для проверки прав доступа) и текущий контекст (хранение произвольных метаданных). В окружении также хранятся кэши.</p><p >Все НЗ имеют окружение, доступ к которой можно получить с помощью <code class="py xref py-attr">env</code> и предоставляет доступ к текущему пользователю (<code class="py xref py-attr">user</code>), курсору  (<code class="py xref py-attr">cr</code>) или контексту(<code class="py xref py-attr">context</code>):</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">records</span><span class="o">.</span><span class="n">env</span>
<span class="go">&lt;Environment object ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">records</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">user</span>
<span class="go">res.user(3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">records</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cr</span>
<span class="go">&lt;Cursor object ...)</span>
</pre></div>
</div>
<p >При создании НЗ из другого набора записей окружение наследуется. Окружение может быть использовано для получения пустого НЗ в другой модели данных а так же для формирования запроса к модели:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="s1">&#39;res.partner&#39;</span><span class="p">]</span>
<span class="go">res.partner</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="s1">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">search</span><span class="p">([[</span><span class="s1">&#39;is_company&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;customer&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>
<span class="go">res.partner(7, 18, 12, 14, 17, 19, 8, 31, 26, 16, 13, 20, 30, 22, 29, 15, 23, 28, 74)</span>
</pre></div>
</div>
</section><section id="altering-the-environment"><h3 >Изменение окружения</h3><p >Окружение может быть скорректировано на основании НЗ. Данная операция возвращает новую версию НЗ, используя измененное окружение.</p><dl ><dt ><a href="#odoo.models.Model.sudo" class="internal reference" title="odoo.models.Model.sudo"><code class="py py-meth xref">sudo()</code></a></dt><dd ><p >Создает новое окружение для данного НЗ с правами доступа указанного пользователя, если пользователь не указан, то предоставляются права администратора, (это может быть полезно для обходя ограничений безопасности в ряде случаев), возвращает копию НЗ, который работает в новом окружении:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># create partner object as administrator</span>
<span class="n">env</span><span class="p">[</span><span class="s1">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sudo</span><span class="p">()</span><span class="o">.</span><span class="n">create</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s2">&quot;A Partner&quot;</span><span class="p">})</span>

<span class="c1"># list partners visible by the &quot;public&quot; user</span>
<span class="n">public</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="s1">&#39;base.public_user&#39;</span><span class="p">)</span>
<span class="n">env</span><span class="p">[</span><span class="s1">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sudo</span><span class="p">(</span><span class="n">public</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">([])</span>
</pre></div>
</div>
</dd><dt ><a href="#odoo.models.Model.sudo" class="internal reference" title="odoo.models.Model.sudo"><code class="py py-meth xref">sudo()</code></a></dt><dd ><ol ><li ><p >Может принимать один позиционный параметр, который заменяет контекст текущего окружения</p></li><li ><p >Может принимать любое количество параметров по ключевому слову, которые добавляются либо в контекст текущего окружения, либо в контекст, заданный во время шага 1</p></li></ol><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># look for partner, or create one with specified timezone if none is</span>
<span class="c1"># found</span>
<span class="n">env</span><span class="p">[</span><span class="s1">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">a_tz</span><span class="p">)</span><span class="o">.</span><span class="n">find_or_create</span><span class="p">(</span><span class="n">email_address</span><span class="p">)</span>
</pre></div>
</div>
</dd><dt ><a href="#odoo.models.Model.with_env" class="internal reference" title="odoo.models.Model.with_env"><code class="py py-meth xref">with_env()</code></a></dt><dd ><p >Полностью заменяет существующее окружение</p></dd></dl></section><section id="common-orm-methods"><h2 >Базовые методы ORM</h2><dl ><dt ><a href="#odoo.models.Model.search" class="internal reference" title="odoo.models.Model.search"><code class="py py-meth xref">search()</code></a></dt><dd ><p >Принимает <a href="#reference-orm-domains" class="internal reference"><span class="std std-ref">параметры поиска в виде домена</span></a>, и возвращает НЗ который удовлетворяют условиям поиска. Может возвращать часть НЗ совпадающих записей (параметры <code >offset</code> и <code >limit</code>) и может быть отсортирован (параметр <code >order</code>):</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># searches the current model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">([(</span><span class="s1">&#39;is_company&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;customer&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)])</span>
<span class="go">res.partner(7, 18, 12, 14, 17, 19, 8, 31, 26, 16, 13, 20, 30, 22, 29, 15, 23, 28, 74)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">([(</span><span class="s1">&#39;is_company&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)],</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;Agrolait&#39;</span>
</pre></div>
</div>
<div role="alert" class="alert-info alert"><h3 class="alert-title">Совет</h3><p >для того, чтобы просто проверить, соответствует ли какая-либо запись домену, или посчитать количество записей, которые соотвествуют, используйте <a href="#odoo.models.Model.search_count" class="internal alert-link reference" title="odoo.models.Model.search_count"><code class="py py-meth xref">search_count()</code></a></p></div></dd><dt ><a href="#odoo.models.Model.create" class="internal reference" title="odoo.models.Model.create"><code class="py py-meth xref">create()</code></a></dt><dd ><p >Принимает несколько значений полей и возвращает НЗ, содержащий созданную запись:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s2">&quot;New Name&quot;</span><span class="p">})</span>
<span class="go">res.partner(78)</span>
</pre></div>
</div>
</dd><dt ><a href="#odoo.models.Model.write" class="internal reference" title="odoo.models.Model.write"><code class="py py-meth xref">write()</code></a></dt><dd ><p >Принимает несколько значений полей, записывает их во все записи в своем НЗ. Ничего не возвращает:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s2">&quot;Newer Name&quot;</span><span class="p">})</span>
</pre></div>
</div>
</dd><dt ><a href="#odoo.models.Model.browse" class="internal reference" title="odoo.models.Model.browse"><code class="py py-meth xref">browse()</code></a></dt><dd ><p >Принимает идентификатор базы данных или список идентификаторов и возвращает НЗ, полезен, когда идентификаторы записей получены извне Odoo (например запрос-ответ от внешней системы) или <a href="#reference-orm-oldapi" class="internal reference"><span class="std std-ref">когда вызываете методы старого API</span></a>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">browse</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">res.partner(7, 18, 12)</span>
</pre></div>
</div>
</dd><dt ><a href="#odoo.models.Model.exists" class="internal reference" title="odoo.models.Model.exists"><code class="py py-meth xref">exists()</code></a></dt><dd ><p >Возвращает новый НЗ, содержащий только записи, существующие в базе данных. Может использоваться для проверки того, существует ли запись (например, полученная извне):</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="ow">not</span> <span class="n">record</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The record has been deleted&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >или после вызова метода, который мог бы удалить некоторые записи:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">records</span><span class="o">.</span><span class="n">may_remove_some</span><span class="p">()</span>
<span class="c1"># only keep records which were not deleted</span>
<span class="n">records</span> <span class="o">=</span> <span class="n">records</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">ref()</code></dt><dd ><p >Метод окружения, возвращающий запись, соответствующую предоставленному <a href="../glossary.html#term-external-id" class="internal reference"><span class="std std-term xref">external id</span></a>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="s1">&#39;base.group_public&#39;</span><span class="p">)</span>
<span class="go">res.groups(2)</span>
</pre></div>
</div>
</dd><dt ><a href="#odoo.models.Model.ensure_one" class="internal reference" title="odoo.models.Model.ensure_one"><code class="py py-meth xref">ensure_one()</code></a></dt><dd ><p >Проверяет, что НЗ являлся ОЗ (содержит только одну запись), в противном случае возникает ошибка:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">records</span><span class="o">.</span><span class="n">ensure_one</span><span class="p">()</span>
<span class="c1"># is equivalent to but clearer than:</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">records</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Expected singleton&quot;</span>
</pre></div>
</div>
</dd></dl></section><section id="creating-models"><h2 >Создание моделей данных</h2><p >Поля модели данных определяются как ее атрибуты:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">odoo</span> <span class="k">import</span> <span class="n">models</span><span class="p">,</span> <span class="n">fields</span>
<span class="k">class</span> <span class="nc">AModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;a.model.name&#39;</span>

    <span class="n">field1</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">()</span>
</pre></div>
</div>
<div role="alert" class="alert-warning alert"><h3 class="alert-title">Предупреждение</h3><p >Это означает, что вы не можете определить как поле так и метод с одинаковым именем, и они будут конфликтовать</p></div><p >По умолчанию метка поля (видимое пользователем имя) является версией имени поля написанной с большой буквы, это может быть переопределено параметром <code >`string</code>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">field2</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s2">&quot;an other field&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >Для различных типов полей и их параметрах смотрите <a href="#reference-orm-fields" class="internal reference"><span class="std std-ref">the fields reference</span></a>.</p><p >Значения по умолчанию определяются как параметры полей с присвоенными им значениями:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a_field</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s2">&quot;a value&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >или функция, которая должна вычислять и возвращать это самое значение по умолчанию:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_default_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
<span class="n">a_field</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">compute_default_value</span><span class="p">)</span>
</pre></div>
</div>
</section><section id="computed-fields"><h3 >Вычисляемые поля</h3><p >Значение полей может быть вычеслено (вместо того, чтобы читать их прямо из базы данных) с помощью параметра <code >compute</code>. <strong >Он должен присвоить вычисленное значение полю</strong>. Если он использует значения других <em >полей</em>, он должен указать эти поля, используя <a href="#odoo.api.depends" class="internal reference" title="odoo.api.depends"><code class="py xref py-func">depends()</code></a>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">odoo</span> <span class="k">import</span> <span class="n">api</span>
<span class="n">total</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s1">&#39;_compute_total&#39;</span><span class="p">)</span>

<span class="nd">@api</span><span class="o">.</span><span class="n">depends</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;tax&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_compute_total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">record</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">record</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">record</span><span class="o">.</span><span class="n">tax</span>
</pre></div>
</div>
<ul ><li ><p >зависимости могут быть указанны в виде ссылки на поле, путь к которому вы описываете через точки:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">depends</span><span class="p">(</span><span class="s1">&#39;line_ids.value&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_compute_total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">record</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">line_ids</span><span class="p">)</span>
</pre></div>
</div>
</li><li ><p >вычисляемые поля по умолчанию не сохраняются, их значения вычисляются и возвращаются по запросу. Параметр <code >store = True</code> сохранит их значение в базе данных и автоматически включит поиск</p></li><li ><p >поиск по вычисленному полю также можно включить, установив параметр <code >search</code>. Значение - это имя метода, возвращающее <a href="#reference-orm-domains" class="internal reference"><span class="std std-ref">Домены</span></a>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">upper_name</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s1">&#39;_compute_upper&#39;</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="s1">&#39;_search_upper&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_search_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;like&#39;</span><span class="p">:</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="s1">&#39;ilike&#39;</span>
    <span class="k">return</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">value</span><span class="p">)]</span>
</pre></div>
</div>
</li><li ><p >для разрешения значений <em >setting</em> в вычислимых полях используйте параметр <code >inverse</code>. Это имя функции, задача которой откатить вычисления и установить в соответствующие поля нужные значения:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">document</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s1">&#39;_get_document&#39;</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="s1">&#39;_set_document&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">get_document_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">record</span><span class="o">.</span><span class="n">document</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_set_document</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">record</span><span class="o">.</span><span class="n">document</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">get_document_path</span><span class="p">())</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">document</span><span class="p">)</span>
</pre></div>
</div>
</li><li ><p >значения для нескольких полей могут быть вычислены одновременно одним и тем же методом, просто используйте его во всех полях и присвойте нужные значения для каждого из них:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">discount_value</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s1">&#39;_apply_discount&#39;</span><span class="p">)</span>
<span class="n">total</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s1">&#39;_apply_discount&#39;</span><span class="p">)</span>

<span class="nd">@depends</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;discount&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_apply_discount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="c1"># compute actual discount from discount percentage</span>
        <span class="n">discount</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">record</span><span class="o">.</span><span class="n">discount</span>
        <span class="n">record</span><span class="o">.</span><span class="n">discount_value</span> <span class="o">=</span> <span class="n">discount</span>
        <span class="n">record</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">discount</span>
</pre></div>
</div>
</li></ul></section><section id="related-fields"><h4 >Реляционные поля</h4><p >Частным случаем вычисляемых полей являются <em >related</em> (proxy) поля, которые предоставляют значение реляционного поля в текущей записи. Они определяются установкой параметра <code >related</code> и могут быть сохранены как обычные вычисляемые поля:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nickname</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">related</span><span class="o">=</span><span class="s1">&#39;user_id.partner_id.name&#39;</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</section><section id="onchange-updating-ui-on-the-fly"><h3 >оnchange: обновление интерфейса на лету</h3><p >Когда пользователь изменяет значение поля в форме (но еще не сохранил форму), бывает, что полезно автоматически обновлять другие поля на основе введенного им значения, например, обновлять итоговую сумму при изменении значения налога или добавления еще одной позиции в счет.</p><ul ><li ><p >Вычисляемые поля автоматически проверяются и пересчитываются, им не требуется <code >onchange</code></p></li><li ><p >для не вычисляемых полей, используется декоратор <a href="#odoo.api.onchange" class="internal reference" title="odoo.api.onchange"><code class="py xref py-func">onchange()</code></a> чтобы предоставить новые значения полей:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">onchange</span><span class="p">(</span><span class="s1">&#39;field1&#39;</span><span class="p">,</span> <span class="s1">&#39;field2&#39;</span><span class="p">)</span> <span class="c1"># if these fields are changed, call method</span>
<span class="k">def</span> <span class="nf">check_change</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">field1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">field2</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field3</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p >изменения, выполненные во время работы этого метода, затем отправляются в клиентскую программу и становятся видимыми для пользователя</p></li><li ><p >Как вычисляемые поля так и принадлежащая новому API функция onchange автоматически вызывается клиентом без необходимости добавлять их в представлениях</p></li><li ><p >Можно исключить триггер который вызывает их работу для определенного поля, добавив <code >on_change=&quot;0&quot;</code> в представлении:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">field</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;name&quot;</span> <span class="n">on_change</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p >обновления интерфейса не будут происходить, если поле редактируется пользователем, даже если в этом поле есть вычисляемые поля или явный вызов onchange.</p></li></ul><div role="alert" class="alert-info alert"><h3 class="alert-title">Примечание</h3><p ><code >onchange</code> методы работают с виртуальными записями присвоение значений этим записям не записываются в базу данных, они просто используются для того, чтобы знать, какое значение отправлять обратно клиенту</p></div><div role="alert" class="alert-warning alert"><h3 class="alert-title">Предупреждение</h3><p >It is not possible for a <code >one2many</code> or <code >many2many</code> field to modify
itself via onchange. This is a webclient limitation - see <a href="https://github.com/odoo/odoo/issues/2693" class="external reference alert-link">#2693</a>.</p></div></section><section id="low-level-sql"><h3 >Использование SQL</h3><p >В окружении атрибут <code class="py xref py-attr">cr</code> является курсором для выполнения транзакции в текущей базе данных и позволяет напрямую выполнять SQL, также применяется для запросов, которые трудно выразить с помощью ORM (например, сложные join'ы), либо для производительности причины:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cr</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;some_sql&quot;</span><span class="p">,</span> <span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">,</span> <span class="n">param3</span><span class="p">)</span>
</pre></div>
</div>
<p >Поскольку модели данных используют один и тот же курсор, а класс <code class="py xref py-class">Environment</code> содержит различные кэши, эти кеши должны быть недействительными при <em >изменении</em> базы данных с помощью чистого SQL, или дальнейшее использование моделей может стать некогерентным. Необходимо очищать кеши при использовании <code >CREATE</code>, <code >UPDATE</code> или <code >DELETE</code> в SQL, но не <code >SELECT</code> (который просто читает базу данных).</p><p >Clearing caches can be performed using the
<code class="py py-meth xref">invalidate_cache()</code> method of the
<code class="py xref py-class">BaseModel</code> object.</p></section><section id="compatibility-between-new-api-and-old-api"><i id="reference-orm-oldapi"></i><h2 >Совместимость между новым API и старым API</h2><p >В настоящее время Odoo переходит со старого (менее упорядоченного) API, возможно потребуется выполнение ряда операций вручную при переходе от одного API к другому:</p><ul ><li ><p >Уровни RPC (как XML-RPC, так и JSON-RPC) выражаются в терминах старого API, методы, выраженные чисто в новом API, недоступны через RPC</p></li><li ><p >переопределенные методы могут быть вызваны из более старых фрагментов кода, все еще написанных на старом API</p></li></ul><p >Здесь представлены наиболее крупные различия между старыми и новыми API:</p><ul ><li ><p >значения класса <code class="py xref py-class">Environment</code> (курсор, идентификатор пользователя и контекст) передаются методу явным образом</p></li><li ><p >записи (<a href="#odoo.models.Model.ids" class="internal reference" title="odoo.models.Model.ids"><code class="py xref py-attr">ids</code></a>) передаются явным образом в методы и, возможно, не передаются вообще</p></li><li ><p >методы, как правило, работают со списками идентификаторов вместо НЗ</p></li></ul><p >По умолчанию предполагается, что методы используют новый API и не могут вызываться из старого API.</p><div role="alert" class="alert-info aphorism alert"><h3 class="alert-title">Совет</h3><p >вызовы из нового API в старый API транслируются</p><p >при использовании нового API вызовы методов, определенных с использованием старого API, автоматически преобразуются «на лету», не нужно делать ничего особенного:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># method in the old API style</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">old_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">ids</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># method in the new API style</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># system automatically infers how to call the old-style</span>
<span class="gp">... </span>    <span class="c1"># method from the new-style method</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">old_method</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="p">[</span><span class="n">model</span><span class="p">]</span><span class="o">.</span><span class="n">browse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">new_method</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
</div><p >Два декоратора могут вызвать новый метод для старого API:</p><dl ><dt ><a href="#odoo.api.model" class="internal reference" title="odoo.api.model"><code class="py xref py-func">model()</code></a></dt><dd ><p >метод предоставляется как не использующий идентификаторы, его НЗ, как правило, пуст. Его сигнатура &quot;старого API&quot; выглядит следующим образом <code >cr, uid, *arguments, context</code>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">model</span>
<span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_value</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="c1"># can be called as</span>
<span class="n">old_style_model</span><span class="o">.</span><span class="n">some_method</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">a_value</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
</dd><dt ><a href="#odoo.api.multi" class="internal reference" title="odoo.api.multi"><code class="py xref py-func">multi()</code></a></dt><dd ><p >метод предоставляется как принимающий список идентификаторов (возможно, пустых), его сигнатура «старого API» выглядит следующим образом <code >cr, uid, ids, *arguments, context</code>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">multi</span>
<span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_value</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="c1"># can be called as</span>
<span class="n">old_style_model</span><span class="o">.</span><span class="n">some_method</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="p">[</span><span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">],</span> <span class="n">a_value</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl><p >Поскольку новые API-интерфейсы склонны возвращать НЗ, а старые API-интерфейсы возвращают списки идентификаторов, поэтому существует декоратор, управляющий этим:</p><dl ><dt ><a href="#odoo.api.returns" class="internal reference" title="odoo.api.returns"><code class="py xref py-func">returns()</code></a></dt><dd ><p >предполагается, что функция возвращает НЗ, первым параметром должно быть имя модели данных которой принадлежит НЗ или <code >self</code> (для текущей модели).</p><p >не будет эффекта, если метод вызывается в новом API, но НЗ будет преобразован в список идентификаторов при вызове из старого API:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@api</span><span class="o">.</span><span class="n">multi</span>
<span class="gp">... </span><span class="nd">@api</span><span class="o">.</span><span class="n">returns</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="bp">self</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_style_model</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;a.model&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_style_model</span><span class="o">.</span><span class="n">some_method</span><span class="p">()</span>
<span class="go">a.model(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_style_model</span> <span class="o">=</span> <span class="n">pool</span><span class="p">[</span><span class="s1">&#39;a.model&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_style_model</span><span class="o">.</span><span class="n">some_method</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
</dd></dl></section><section id="model-reference"><i id="reference-orm-model"></i><h2 >Ссылки на модели данных</h2><section class="code-class"><h6 id="odoo.models.Model"><code><em >class </em>odoo.models.Model(<em>pool</em>, <em>cr</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L5194" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Основной суперкласс для регулярных моделей Odoo, поддерживающих базу данных.</p><p >Одоо модели создаются наследованием от этого класса</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">user</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p >Позже система создаст экземпляр класса один раз для каждой базы данных (на которой установлен модуль класса).</p><h3 >Структурные атрибуты</h3><section class="code-attribute"><h6 id="odoo.models.Model._name"><code>_name</code></h6><p >наименование бизнес-объекта, в dot-нотации (в пространстве имен модуля)</p></section><section class="code-attribute"><h6 id="odoo.models.Model._rec_name"><code>_rec_name</code></h6><p >Альтернативное поле для использования в качестве наименования, используемое osv’s name_get() (по умолчанию: <code >'name'</code>)</p></section><section class="code-attribute"><h6 id="odoo.models.Model._inherit"><code>_inherit</code></h6><ul ><li ><p >Если атрибут <a href="#odoo.models.Model._name" class="internal alert-link reference" title="odoo.models.Model._name"><code class="py xref py-attr">_name</code></a> указан, то он должен содержать имена родительских моделей данных, которые он наследует. Может быть <code >str</code>, если происходит наследование от одного родителя</p></li><li ><p >Если атрибут <a href="#odoo.models.Model._name" class="internal alert-link reference" title="odoo.models.Model._name"><code class="py xref py-attr">_name</code></a> не указан, то происходит расширение конкретной модели данных</p></li></ul><p >Смотрите <a href="#reference-orm-inheritance" class="internal alert-link reference"><span class="std std-ref">Наследование и расширение</span></a>.</p></section><section class="code-attribute"><h6 id="odoo.models.Model._order"><code>_order</code></h6><p >Поле указывающее на порядок сортировки при поиске указывать не требуется (по умолчанию сортировка происходит по: <code >'id'</code>)</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body">str</div></div></div></section><section class="code-attribute"><h6 id="odoo.models.Model._auto"><code>_auto</code></h6><blockquote ><p >Должна ли создаваться таблица базы данных (по умолчанию: <code >True</code>)</p><p >Если установлено значение <code >False</code>, переопределите <code class="py py-meth xref">init`()</code> для создания таблицы базы данных</p></blockquote><div role="alert" class="alert-info alert"><h3 class="alert-title">Совет</h3><p >To create a model without any table, inherit
from <code >odoo.models.AbstractModel</code></p></div></section><section class="code-attribute"><h6 id="odoo.models.Model._table"><code>_table</code></h6><p >Имя таблицы, с которой связана модель данных, созданной при использовании атрибута  <a href="#odoo.models.Model._auto" class="internal alert-link reference" title="odoo.models.Model._auto"><code class="py xref py-attr">_auto</code></a>, автоматически генерируется по умолчанию.</p></section><section class="code-attribute"><h6 id="odoo.models.Model._inherits"><code>_inherits</code></h6><p >словарь, сопоставляющий _name родительских бизнес-объектов с именами соответствующих полей внешнего ключа для использования:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">_inherits</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;a.model&#39;</span><span class="p">:</span> <span class="s1">&#39;a_field_id&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b.model&#39;</span><span class="p">:</span> <span class="s1">&#39;b_field_id&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p >реализует композиционное наследование: новая модель данных предоставляет все поля модели <a href="#odoo.models.Model._inherits" class="internal alert-link reference" title="odoo.models.Model._inherits"><code class="py xref py-attr">_inherits</code></a>, но не хранит ни одного из них: сами значения остаются в связанной записи.</p><div role="alert" class="alert-warning alert"><h3 class="alert-title">Предупреждение</h3><p >если одно и то же поле определено по нескольким параметрам <a href="#odoo.models.Model._inherits" class="internal alert-link reference" title="odoo.models.Model._inherits"><code class="py xref py-attr">_inherits</code></a></p></div></section><section class="code-attribute"><h6 id="odoo.models.Model._constraints"><code>_constraints</code></h6><p >Список <code >(constraint_function, message, fields)</code>, определяющий ограничения для Python. Список полей является ориентировочным</p><div class="deprecated"><p ><span class="versionmodified">Не рекомендуется, начиная с версии 8.0: </span>use <a href="#odoo.api.constrains" class="internal alert-link reference" title="odoo.api.constrains"><code class="py xref py-func">constrains()</code></a></p></div></section><section class="code-attribute"><h6 id="odoo.models.Model._sql_constraints"><code>_sql_constraints</code></h6><p >список триплетов <code >(name, sql_definition, message)</code> , определяющих SQL-ограничения при создании резервной таблицы</p></section><section class="code-attribute"><h6 id="odoo.models.Model._parent_store"><code>_parent_store</code></h6><p >Атрибут <a href="#odoo.models.Model.parent_left" class="internal alert-link reference" title="odoo.models.Model.parent_left"><code class="py xref py-attr">parent_left</code></a> and [UNKNOWN NODE problematic] для включения быстрых иерархических запросов к записям текущей модели (по умолчанию: <code >False</code>)</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body">bool</div></div></div></section><h3 >CRUD</h3><section class="code-method"><h6 id="odoo.models.Model.create"><code>create(<em>vals</em>) → record<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L3324" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Создает новую запись для модели.</p><p >Новая запись инициализируется с использованием значений из `` vals`` и при необходимости из: meth: <code >~ .default_get</code>.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >vals</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#dict" class="external reference alert-link" title="(в Python v3.7)"><code >dict</code></a>) -- Значения для полей модели, как словарь :: {'field_name': field_value, ...} see: meth: <code >~ .write</code> для деталей</div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Новая запись создана</div></div><div class="code-field"><div class="code-field-name">Исключение</div><div class="code-field-body"><ul ><li ><strong >AccessError</strong> -- <ul ><li ><p >Если у пользователя нет прав на создание объекта</p></li><li ><p >Если пользователь пытается обойти правила доступа для создания на запрошенном объекте</p></li></ul></li><li ><strong >ValidateError</strong> -- Если пользователь пытается ввести недопустимое значение для поля, которое не выбрано</li><li ><strong >UserError</strong> -- Если в иерархии объектов будет создан цикл в результате операции (такой как установка объекта как собственного родителя)</li></ul></div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.browse"><code>browse([<em>ids</em>]) → records<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L4328" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает набор записей для идентификаторов, предоставленных в качестве параметра в текущей среде.</p><p >Не может принимать идентификаторы, одиночный идентификатор или последовательность идентификаторов.</p></section><section class="code-method"><h6 id="odoo.models.Model.unlink"><code>unlink()<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L2897" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Удаляет записи текущего набора</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Исключение</div><div class="code-field-body"><ul ><li ><strong >AccessError</strong> -- <ul ><li ><p >Если у пользователя нет прав развязки на запрошенном объекте</p></li><li ><p >Если пользователь пытается обойти правила доступа для развязки на запрошенном объекте</p></li></ul></li><li ><strong >UserError</strong> -- Если запись является свойством по умолчанию для других записей</li></ul></div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.write"><code>write(<em>vals</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L2978" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Обновляет все записи в текущем наборе с предоставленными значениями.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >vals</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#dict" class="external reference alert-link" title="(в Python v3.7)"><code >dict</code></a>) -- Поля для обновления и значение для них, например: :: {'foo': 1, 'bar': &quot;Qux&quot;} установите поле <code >foo</code> в <code >1</code>, ​​а поле <code >Bar</code> в <code >&quot;Qux&quot;</code> если они действительны (иначе это вызовет ошибку).</div></div><div class="code-field"><div class="code-field-name">Исключение</div><div class="code-field-body"><ul ><li ><strong >AccessError</strong> -- <ul ><li ><p >Если у пользователя нет прав на запись для запрашиваемого объекта</p></li><li ><p >Если пользователь пытается обойти правила доступа для записи на запрошенном объекте</p></li></ul></li><li ><strong >ValidateError</strong> -- Если пользователь пытается ввести недопустимое значение для поля, которое не выбрано</li><li ><strong >UserError</strong> -- Если в иерархии объектов будет создан цикл в результате операции (такой как установка объекта как собственного родителя)</li></ul></div></div></div><ul ><li ><p >Для числовых полей (: class: <code >~ odoo.fields.Integer</code>,: class:` ~ odoo.fields.Float`) значение должно быть соответствующего типа</p></li><li ><p >Для: class: <code >~ odoo.fields.Boolean</code>, значение должно быть: class:` python: bool`</p></li><li ><p >Для: class: <code >~ odoo.fields.Selection</code>, значение должно соответствовать значениям выбора (обычно: class:` python: str`, иногда: class: <code >python: int</code>)</p></li><li ><p >Для: class: <code >~ odoo.fields.Many2one</code>, значение должно быть идентификатором базы данных для записи</p></li><li ><p >Другие нереляционные поля используют строку для значения</p><div role="alert" class="alert-danger alert"><h3 class="alert-title">Опасно</h3><p >По историческим причинам и причинам совместимости: class: <code >~ odoo.fields.Date</code> и: class:` ~ odoo.fields.Datetime` поля используют строки как значения (написанные и прочитанные), а не: class: <code >~ python: datetime. Date</code> или: class: <code >~ python: datetime.datetime</code>. Эти строки даты являются UTC-only и отформатированы в соответствии с: const: <code >odoo.tools.misc.DEFAULT_SERVER_DATE_FORMAT</code> и: const:` odoo.tools.misc.DEFAULT_SERVER_DATETIME_FORMAT`</p></div></li><li ><p id="openerp-models-relationals-format">: Class: <code >~ odoo.fields.One2many</code> и: class:` ~ odoo.fields.Many2many` используют специальный формат &quot;команды&quot; для управления набором записей, хранящихся в / связанных с этим полем.</p><p >Этот формат представляет собой список триплетов, выполняемых последовательно, где каждый триплет является командой, выполняемой по набору записей. Не все команды применяются во всех ситуациях. Возможные команды:</p><dl ><dt >Значения(s)</dt><dd ><p >Добавляет новую запись, созданную из предоставленного `` значения`` dict.</p></dd><dt >`` (1, id, значения) ``</dt><dd ><p >Обновляет существующую запись id `` id`` со значениями в `` значения``. Нельзя использовать в: мет: <code >~ .create</code>.</p></dd><dt >Ид</dt><dd ><p >Удаляет запись id `` id`` из набора, а затем удаляет его (из базы данных). Нельзя использовать в: мет: <code >~ .create</code>.</p></dd><dt >Ид</dt><dd ><p >Удаляет запись id `` id`` из набора, но не удаляет его. Нельзя использовать: class: <code >~ odoo.fields.One2many</code>. Нельзя использовать в: мет: <code >~ .create</code>.</p></dd><dt >Ид</dt><dd ><p >Добавляет существующую запись id `` id`` в набор. Нельзя использовать: class: <code >~ odoo.fields.One2many</code>.</p></dd><dt ><code >(5, _, _)</code></dt><dd ><p >Удаляет все записи из набора, что эквивалентно использованию команды `` 3`` для каждой записи явно. Нельзя использовать: class: <code >~ odoo.fields.One2many</code>. Нельзя использовать в: мет: <code >~ .create</code>.</p></dd><dt >Ids1</dt><dd ><p >Заменяет все существующие записи в наборе списком `` ids``, что эквивалентно использованию команды `` 5``, за которой следует команда `` 4`` для каждого `` id`` в `` ids``.</p></dd></dl><div role="alert" class="alert-info alert"><h3 class="alert-title">Примечание</h3><p >Значения, отмеченные как `` _` в списке выше, игнорируются и могут быть любыми, обычно `` 0`` или `` Ложно``.</p></div></li></ul></section><section class="code-method"><h6 id="odoo.models.Model.read"><code>read([<em>fields</em>])<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L2557" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Читает запрошенные поля для записей в `` self``, низкоуровневом / RPC-методе. В коде Python предпочитайте: meth: <code >~ .browse</code>.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >fields</strong> -- Список имен полей для возврата (по умолчанию все поля)</div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Список словарей, отображающих имена полей в их значениях, с одним словарем на запись</div></div><div class="code-field"><div class="code-field-name">Исключение</div><div class="code-field-body"><strong >AccessError</strong> -- Если у пользователя нет прав на чтение некоторых из данных записей</div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.read_group"><code>read_group(<em>domain</em>, <em>fields</em>, <em>groupby</em>, <em>offset=0</em>, <em>limit=None</em>, <em>orderby=False</em>, <em>lazy=True</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L1878" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Получить список записей в виде списка, сгруппированных по заданным полям `` groupby``</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >domain</strong> -- Список, определяющий критерии поиска [['field_name', 'operator', 'value'], ...]</li><li ><strong >fields</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" class="external reference alert-link" title="(в Python v3.7)"><code >list</code></a>) -- Список полей, представленных в виде списка, указанного на объекте</li><li ><strong >groupby</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" class="external reference alert-link" title="(в Python v3.7)"><code >list</code></a>) -- Список групп по описаниям, по которым записи будут сгруппированы. Групповое описание представляет собой либо поле (тогда оно будет сгруппировано по этому полю), либо поле 'field: groupby_function'. Прямо сейчас единственными поддерживаемыми функциями являются «день», «неделя», «месяц», «квартал» или «год», и они имеют смысл только для полей даты и времени.</li><li ><strong >offset</strong> (<a href="https://docs.python.org/3/library/functions.html#int" class="external reference alert-link" title="(в Python v3.7)"><code >int</code></a>) -- Необязательное количество записей для пропуска</li><li ><strong >limit</strong> (<a href="https://docs.python.org/3/library/functions.html#int" class="external reference alert-link" title="(в Python v3.7)"><code >int</code></a>) -- Необязательное максимальное количество возвращаемых записей</li><li ><strong >orderby</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" class="external reference alert-link" title="(в Python v3.7)"><code >list</code></a>) -- Необязательная спецификация `` order by``, для переопределения естественного порядка сортировки групп, см. Также: py: meth: <code >~ osv.osv.osv.search</code> (поддерживается только для многих полей в настоящее время)</li><li ><strong >lazy</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" class="external reference alert-link" title="(в Python v3.7)"><code >bool</code></a>) -- Если true, результаты группируются только первой группой, а остальные groupbys помещаются в ключ __context. Если false, все groupbys выполняются за один вызов.</li></ul></div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Список словарей (один словарь для каждой записи), содержащий: * значения полей, сгруппированных по полям в аргументе `` groupby`` * __domain: список кортежей, определяющих критерии поиска * __context: словарь с аргументом типа `` groupby``</div></div><div class="code-field"><div class="code-field-name">Тип результата</div><div class="code-field-body">[{'field_name_1': value, ...]</div></div><div class="code-field"><div class="code-field-name">Исключение</div><div class="code-field-body"><strong >AccessError</strong> -- <ul ><li ><p >Если пользователь не имеет прав на запрашиваемый объект</p></li><li ><p >Если пользователь пытается обойти правила доступа для чтения на запрошенном объекте</p></li></ul></div></div></div></section><h3 >Поиск</h3><section class="code-method"><h6 id="odoo.models.Model.search"><code>search(<em>args[, offset=0][, limit=None][, order=None][, count=False]</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L1460" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Ищет записи, основанные на `` args``: ref: <code >search domain &lt;reference / orm / domains&gt;</code>.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >args</strong> -- : Ref: <code >Поисковый домен &lt;ссылка / orm / domains&gt;</code>. Используйте пустой список для соответствия всем записям.</li><li ><strong >offset</strong> (<a href="https://docs.python.org/3/library/functions.html#int" class="external reference alert-link" title="(в Python v3.7)"><code >int</code></a>) -- Количество игнорируемых результатов (по умолчанию: нет)</li><li ><strong >limit</strong> (<a href="https://docs.python.org/3/library/functions.html#int" class="external reference alert-link" title="(в Python v3.7)"><code >int</code></a>) -- Максимальное количество возвращаемых записей (по умолчанию: все)</li><li ><strong >order</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" class="external reference alert-link" title="(в Python v3.7)"><code >str</code></a>) -- Строка сортировки</li><li ><strong >count</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" class="external reference alert-link" title="(в Python v3.7)"><code >bool</code></a>) -- Если «Истина», только подсчитывает и возвращает количество совпадающих записей (по умолчанию: False)</li></ul></div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Не более <code >limit`</code> записей, соответствующих критериям поиска</div></div><div class="code-field"><div class="code-field-name">Исключение</div><div class="code-field-body"><strong >AccessError</strong> -- <ul ><li ><p >Если пользователь пытается обойти правила доступа для чтения на запрошенном объекте.</p></li></ul></div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.search_count"><code>search_count(<em>args</em>) → int<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L1450" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает количество записей в текущем совпадении модели: ref: <code >предоставленный домен &lt;reference / orm / domains&gt;</code>.</p></section><section class="code-method"><h6 id="odoo.models.Model.name_search"><code>name_search(<em>name=''</em>, <em>args=None</em>, <em>operator='ilike'</em>, <em>limit=100</em>) → records<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L1537" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Искать записи, у которых есть отображаемое имя, соответствующее заданному шаблону `` name``, по сравнению с указанным `` operator``, а также соответствие необязательной области поиска (`` args``).</p><p >Это используется, например, для предоставления предложений, основанных на частичном значении для реляционного поля. Иногда можно рассматривать как обратную функцию: meth: <code >~ .name_get</code>, но это не гарантируется.</p><p >Этот метод эквивалентен вызову: meth: <code >~ .search</code> с поисковым доменом на основе` <code >display_name`</code>, а затем: meth:` ~ .name_get` по результату поиска.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" class="external reference alert-link" title="(в Python v3.7)"><code >str</code></a>) -- Шаблон имени, который нужно сопоставить</li><li ><strong >args</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" class="external reference alert-link" title="(в Python v3.7)"><code >list</code></a>) -- Необязательный домен поиска (см.: Meth: <code >~ .search</code> для синтаксиса), указав дальнейшие ограничения</li><li ><strong >operator</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" class="external reference alert-link" title="(в Python v3.7)"><code >str</code></a>) -- Domain для сопоставления `` name``, например `` 'like'`` или <code >' = '</code>.</li><li ><strong >limit</strong> (<a href="https://docs.python.org/3/library/functions.html#int" class="external reference alert-link" title="(в Python v3.7)"><code >int</code></a>) -- Необязательное максимальное количество возвращаемых записей</li></ul></div></div><div class="code-field"><div class="code-field-name">Тип результата</div><div class="code-field-body"><a href="https://docs.python.org/3/library/stdtypes.html#list" class="external reference alert-link" title="(в Python v3.7)">list</a></div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Список пар `` (id, text_repr) `` для всех совпадающих записей.</div></div></div></section><h3 >Операции с НЗ</h3><section class="code-attribute"><h6 id="odoo.models.Model.ids"><code>ids</code></h6><p >Список фактических идентификаторов записей в этом наборе записей (игнорирует идентификаторы-заполнители для создаваемых записей)</p></section><section class="code-method"><h6 id="odoo.models.Model.ensure_one"><code>ensure_one()<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L4360" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Проверяет, что текущий recorset содержит одну запись. В противном случае возникает исключение.</p></section><section class="code-method"><h6 id="odoo.models.Model.exists"><code>exists() → records<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L3950" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает подмножество записей в `` self``, которые существуют, и помечает удаленные записи как таковые в кеше. Его можно использовать в качестве теста на записях</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p >По соглашению, новые записи возвращаются как существующие.</p></section><section class="code-method"><h6 id="odoo.models.Model.filtered"><code>filtered(<em>func</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L4531" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Выберите записи в `` self``, чтобы `` func (rec) `` было истинно, и верните их как набор записей.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >func</strong> -- Функция или разделенная точками последовательность имен полей</div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.sorted"><code>sorted(<em>key=None</em>, <em>reverse=False</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L4542" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает набор записей `` self``, упорядоченный `` key``.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >key</strong> -- Либо функцию одного аргумента, который возвращает ключ сравнения для каждой записи, либо имя поля, либо `` None``, в этом случае записи упорядочиваются в соответствии с заказом модели по умолчанию</li><li ><strong >reverse</strong> -- Если `` True``, вернуть результат в обратном порядке</li></ul></div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.mapped"><code>mapped(<em>func</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L4499" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Примените `` func`` во всех записях в `` self``, и верните результат в виде списка или набора записей (если `` func`` возвращает записи). В последнем случае порядок возвращаемого набора записей произволен.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >func</strong> -- Функция или разделенная точками последовательность имен полей (строка); Любое ложное значение просто возвращает набор записей `` self``</div></div></div></section><h3 >Обмен окружением</h3><section class="code-method"><h6 id="odoo.models.Model.sudo"><code>sudo([<em>user=SUPERUSER</em>])<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L4382" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает новую версию этого набора записей, прикрепленного к предоставленному пользователю.</p><p >По умолчанию это возвращает набор записей `` SUPERUSER``, где контроль доступа и правила записи обходят.</p><div role="alert" class="alert-info alert"><h3 class="alert-title">Примечание</h3><p >Использование `` sudo`` может привести к тому, что доступ к данным будет пересекать границы правил записи, возможно, смешивая записи, которые должны быть изолированы (например, записи разных компаний в среде нескольких компаний).</p><p >Это может привести к неинтуитивным результатам в методах, которые выбирают одну запись среди многих - например, получение компании по умолчанию или выбор спецификации.</p></div><div role="alert" class="alert-info alert"><h3 class="alert-title">Примечание</h3><p >Поскольку правила записи и контроля доступа должны быть пересмотрены, новый набор записей не получит преимущества от кэша данных текущей среды, поэтому в дальнейшем доступ к данным может потребовать дополнительных задержек при повторной выборке из базы данных. Возвращенный набор записей имеет тот же объект предварительной выборки, что и `` self``.</p></div></section><section class="code-method"><h6 id="odoo.models.Model.with_context"><code>with_context(<em>[context][, **overrides]</em>) → records<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L4413" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает новую версию этого набора записей, присоединенного к расширенному контексту.</p><p >Расширенным контекстом является либо предоставленный контекст, в котором объединены `` overrides``, либо * текущий * контекст, в котором объединены `` overrides`` например:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># current context is {&#39;key1&#39;: True}</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">records</span><span class="o">.</span><span class="n">with_context</span><span class="p">({},</span> <span class="n">key2</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># -&gt; r2._context is {&#39;key2&#39;: True}</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">records</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">key2</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># -&gt; r2._context is {&#39;key1&#39;: True, &#39;key2&#39;: True}</span>
</pre></div>
</div>
</section><section class="code-method"><h6 id="odoo.models.Model.with_env"><code>with_env(<em>env</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L4368" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает новую версию этого набора записей, прикрепленного к предоставленной среде.</p><div role="alert" class="alert-warning alert"><h3 class="alert-title">Предупреждение</h3><p >Новая среда не получит преимущества от кэша данных текущей среды, поэтому в дальнейшем доступ к данным может потребовать дополнительных задержек при повторной выборке из базы данных. Возвращенный набор записей имеет тот же объект предварительной выборки, что и `` self``.</p></div><div class="code-fields"></div></section><h3 >Запросы полей и представлений</h3><section class="code-method"><h6 id="odoo.models.Model.fields_get"><code>fields_get(<em>[fields][, attributes]</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L2481" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает определение каждого поля.</p><p >Возвращаемое значение - словарь (обозначается именем поля) словарей. Включены поля _inherits'd. Атрибуты string, help и selection (если присутствуют) транслируются.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >allfields</strong> -- Список полей для документа, все, если они пусты или не указаны</li><li ><strong >attributes</strong> -- Список атрибутов описания, возвращаемых для каждого поля, все, если они пусты или не указаны</li></ul></div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.fields_view_get"><code>fields_view_get([<em>view_id | view_type='form'</em>])<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L1355" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Получить подробный состав запрашиваемого представления, например поля, модель, вид архитектуры</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >view_id</strong> -- Идентификатор представления или Нет</li><li ><strong >view_type</strong> -- Тип представления, возвращаемого, если view_id равно None ('form', 'tree', ...)</li><li ><strong >toolbar</strong> -- True для включения контекстных действий</li><li ><strong >submenu</strong> -- Устарело</li></ul></div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Словарь, описывающий состав запрошенного представления (включая унаследованные представления и расширения)</div></div><div class="code-field"><div class="code-field-name">Исключение</div><div class="code-field-body"><ul ><li ><a href="https://docs.python.org/3/library/exceptions.html#AttributeError" class="external reference alert-link" title="(в Python v3.7)"><strong >AttributeError</strong></a> -- <ul ><li ><p >Если унаследованное представление имеет неизвестную позицию для работы с другими, чем «до», «после», «внутри», «заменить»,</p></li><li ><p >Если в родительском представлении обнаружен какой-либо тег, отличный от 'position'</p></li></ul></li><li ><strong >Invalid ArchitectureError</strong> -- Если есть вид, отличный от формы, дерева, календаря, поиска и т. Д., Определенных в структуре</li></ul></div></div></div></section><h3 >Различные методы</h3><section class="code-method"><h6 id="odoo.models.Model.default_get"><code>default_get(<em>fields</em>) → default_values<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L1042" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращайте значения по умолчанию для полей в `` fields_list``. Значения по умолчанию определяются контекстом, пользовательскими настройками по умолчанию и самой моделью.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >fields_list</strong> -- Список имен полей</div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Словарь, отображающий каждое имя поля в соответствующее значение по умолчанию, если оно есть.</div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.copy"><code>copy(<em>default=None</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L3931" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Дублировать запись `` self``, обновляя ее значениями по умолчанию</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >default</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#dict" class="external reference alert-link" title="(в Python v3.7)"><code >dict</code></a>) -- Словарь значений поля для переопределения в исходных значениях скопированной записи, например: `` {'field_name': overridden_value, ...} ``</div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">новая запись</div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.name_get"><code>name_get() → [(id, name), ...]<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L1493" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает текстовое представление для записей в `` self``. По умолчанию это значение поля `` display_name``.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Список пар `` (id, text_repr) `` для каждой записи</div></div><div class="code-field"><div class="code-field-name">Тип результата</div><div class="code-field-body">list(tuple)</div></div></div></section><section class="code-method"><h6 id="odoo.models.Model.name_create"><code>name_create(<em>name</em>) → record<a href="https://github.com/odoo/odoo/blob/11.0/odoo/models.py#L1515" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Создайте новую запись, вызвав: meth: <code >~ .create</code>, указав только одно значение: отображаемое имя новой записи.</p><p >Новая запись будет инициализироваться с любыми значениями по умолчанию, применимыми к этой модели или предоставляемыми через контекст. Применяется обычное поведение: meth: <code >~ .create</code>.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >name</strong> -- Отображаемое имя создаваемой записи</div></div><div class="code-field"><div class="code-field-name">Тип результата</div><div class="code-field-body"><a href="https://docs.python.org/3/library/stdtypes.html#tuple" class="external reference alert-link" title="(в Python v3.7)">tuple</a></div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Параметр: meth: <code >~ .name_get</code> для созданной записи</div></div></div></section><h3 id="reference-orm-model-automatic">Автоматические поля</h3><section class="code-attribute"><h6 id="odoo.models.Model.id"><code>id</code></h6><p >Идентификатор <a href="#odoo.fields.Field" class="internal alert-link reference" title="odoo.fields.Field"><code class="py xref py-class">field</code></a></p></section><section class="code-attribute"><h6 id="odoo.models.Model._log_access"><code>_log_access</code></h6><p >Должны быть созданы поля для журналирования действий пользователей (<code >create_date</code>, <code >write_uid</code>, ...) (по умолчанию: <code >True</code>)</p></section><section class="code-attribute"><h6 id="odoo.models.Model.create_date"><code>create_date</code></h6><p >Дата создания записи</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body"><p >ласс: <code >~ odoo.field.Datetime</code></p></div></div></div></section><section class="code-attribute"><h6 id="odoo.models.Model.create_uid"><code>create_uid</code></h6><p >Реляционное поле для пользователя, создавшего запись</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body"><code >res.users</code></div></div></div></section><section class="code-attribute"><h6 id="odoo.models.Model.write_date"><code>write_date</code></h6><p >Дата последнего изменения записи</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body"><p >ласс: <code >~ odoo.field.Datetime</code></p></div></div></div></section><section class="code-attribute"><h6 id="odoo.models.Model.write_uid"><code>write_uid</code></h6><p >Реляционное поле для пользователя, который последним изменил запись</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body"><code >res.users</code></div></div></div></section><h3 >Зарезервированные имена полей</h3><p >Несколько имен полей зарезервированы для предопределенных сценариев, которые отличаются от автоматически заполняемых полей. Они должны быть определены в модели данных, когда настраивается желаемое поведение:</p><section class="code-attribute"><h6 id="odoo.models.Model.name"><code>name</code></h6><p >значение по умолчанию для <a href="#odoo.models.Model._rec_name" class="internal alert-link reference" title="odoo.models.Model._rec_name"><code class="py xref py-attr">_rec_name</code></a>, используется для отображения записей в контексте, где требуется репрезентативное &quot;наименование&quot;.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body"><a href="#odoo.fields.Char" class="internal alert-link reference" title="odoo.fields.Char"><code class="py xref py-class">Char</code></a></div></div></div></section><section class="code-attribute"><h6 id="odoo.models.Model.active"><code>active</code></h6><p >позволяет отключать глобальную видимость записи, если параметр <code >active</code> установлен на <code >False</code>, запись невидима в большинстве поисковых запросов и подсказок</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body"><a href="#odoo.fields.Boolean" class="internal alert-link reference" title="odoo.fields.Boolean"><code class="py xref py-class">Boolean</code></a></div></div></div></section><section class="code-attribute"><h6 id="odoo.models.Model.sequence"><code>sequence</code></h6><p >Изменяемые критерии сортировки, дпозволяет перетаскивать записи модели данных в представлениях в виде списка</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body"><a href="#odoo.fields.Integer" class="internal alert-link reference" title="odoo.fields.Integer"><code class="py xref py-class">Integer</code></a></div></div></div></section><section class="code-attribute"><h6 id="odoo.models.Model.state"><code>state</code></h6><p >этапы жизненного цикла объекта, используемые атрибутом <code >состояния</code> в классе : <a href="#odoo.fields.Field" class="internal alert-link reference" title="odoo.fields.Field"><code class="py xref py-class">fields</code></a></p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body"><a href="#odoo.fields.Selection" class="internal alert-link reference" title="odoo.fields.Selection"><code class="py xref py-class">Selection</code></a></div></div></div></section><section class="code-attribute"><h6 id="odoo.models.Model.parent_id"><code>parent_id</code></h6><p >используется для упорядочивания записей в древовидной структуре и включения оператора <code >child_of</code> в доменах</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Type</div><div class="code-field-body"><a href="#odoo.fields.Many2one" class="internal alert-link reference" title="odoo.fields.Many2one"><code class="py xref py-class">Many2one</code></a></div></div></div></section><section class="code-attribute"><h6 id="odoo.models.Model.parent_left"><code>parent_left</code></h6><p >используется с <a href="#odoo.models.Model._parent_store" class="internal alert-link reference" title="odoo.models.Model._parent_store"><code class="py xref py-attr">_parent_store</code></a>, позволяет быстрее обращаться к древовидной структуре</p></section><section class="code-attribute"><h6 id="odoo.models.Model.parent_right"><code>parent_right</code></h6><p >смотрите <a href="#odoo.models.Model.parent_left" class="internal alert-link reference" title="odoo.models.Model.parent_left"><code class="py xref py-attr">parent_left</code></a></p></section></section></section><section id="module-odoo.api"><i id="method-decorators"></i><i id="reference-orm-decorators"></i><h2 >Декораторы методов</h2><p >Этот модуль предоставляет элементы для управления двумя разными стилями API, а именно «старым стилем» и «новым стилем».</p><p >В старом стиле такие параметры как курсор базы данных, идентификатор пользователя, словарь контекста и идентификаторы записи (обычно обозначаемые как <code >cr</code>, <code >uid</code>, <code >context</code>, <code >ids</code>) Передаются явным образом всем методам. В в новом стиле эти параметры скрыты в экземплярах модели данных, что придает ему более объектно-ориентированный вид.</p><p >Например, выражения:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">MODEL</span><span class="p">)</span>
<span class="n">ids</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">DOMAIN</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
<span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">rec</span><span class="o">.</span><span class="n">name</span>
<span class="n">model</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">VALUES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
<p >также может быть записано как:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="c1"># cr, uid, context wrapped in env</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="n">MODEL</span><span class="p">]</span>                  <span class="c1"># retrieve an instance of MODEL</span>
<span class="n">recs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">DOMAIN</span><span class="p">)</span>         <span class="c1"># search returns a recordset</span>
<span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">recs</span><span class="p">:</span>                    <span class="c1"># iterate over the records</span>
    <span class="nb">print</span> <span class="n">rec</span><span class="o">.</span><span class="n">name</span>
<span class="n">recs</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">VALUES</span><span class="p">)</span>                  <span class="c1"># update all records in recs</span>
</pre></div>
</div>
<p >Методы, написанные в &quot;старом&quot; стиле, автоматически оформляются, следуя некоторым эвристическим методам, основанным на именах параметров.</p><section class="code-function"><h6 id="odoo.api.multi"><code>odoo.api.multi(<em>method</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/api.py#L322" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Задекорируйте метод в новом стиле, где <code >self</code> - НЗ. Этот метод обычно определяет операцию над записями. Таким способом:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">multi</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p >может быть вызван как в старом, так и в новом стиле, например:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># recs = model.browse(cr, uid, ids, context)</span>
<span class="n">recs</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
</section><section class="code-function"><h6 id="odoo.api.model"><code>odoo.api.model(<em>method</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/api.py#L301" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Задекорируйте метод в новом стиле, где <code >self</code> - НЗ, но его содержимое не релевантно, только модель данных. Таким способом:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">model</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p >может быть вызван как в старом, так и в новом стиле, например:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># recs = model.browse(cr, uid, ids, context)</span>
<span class="n">recs</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
<p >Обратите внимание, что <code >ids</code> передаются в методы только в старом стиле.</p></section><section class="code-function"><h6 id="odoo.api.depends"><code>odoo.api.depends(<em>*args</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/api.py#L201" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает декоратор, который задает зависимости полей для метода &quot;compute&quot; (для вычисляемых полей в новом стиле). Каждый аргумент должен быть строкой, состоящей из разделенных точками последовательностей имен полей:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pname</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s1">&#39;_compute_pname&#39;</span><span class="p">)</span>

<span class="nd">@api</span><span class="o">.</span><span class="n">one</span>
<span class="nd">@api</span><span class="o">.</span><span class="n">depends</span><span class="p">(</span><span class="s1">&#39;partner_id.name&#39;</span><span class="p">,</span> <span class="s1">&#39;partner_id.is_company&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_compute_pname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partner_id</span><span class="o">.</span><span class="n">is_company</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pname</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partner_id</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partner_id</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p >В качестве аргумента можно передать одну функцию. В этом случае зависимости задаются вызовом функции поля модели данных.</p></section><section class="code-function"><h6 id="odoo.api.constrains"><code>odoo.api.constrains(<em>*args</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/api.py#L138" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Декорирует проверку ограничений. Каждый аргумент должен быть именем поля, используемым для проверки:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">one</span>
<span class="nd">@api</span><span class="o">.</span><span class="n">constrains</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_check_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;Fields name and description must be different&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >Вызывается для записей в новом стиле, в которых одно из именованных полей было изменено.</p><p >Должен быть вызван класс <code class="py xref py-class">ValidationError</code>, если проверка не прошла.</p><div role="alert" class="alert-warning alert"><h3 class="alert-title">Предупреждение</h3><p ><code >@constrains</code> поддерживает только простые имена полей, имена через точку (поля реляционных полей, например <code >partner_id.customer</code>) не поддерживаются и будут игнорироваться</p><p ><code >@constrains</code> will be triggered only if the declared fields in the
decorated method are included in the <code >create</code> or <code >write</code> call.
It implies that fields not present in a view will not trigger a call
during a record creation. A override of <code >create</code> is necessary to make
sure a constraint will always be triggered (e.g. to test the absence of
value).</p></div></section><section class="code-function"><h6 id="odoo.api.onchange"><code>odoo.api.onchange(<em>*args</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/api.py#L170" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает декоратор, чтобы задекорировать метод onchange для заданных полей. Каждый аргумент должен быть именем поля:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">onchange</span><span class="p">(</span><span class="s1">&#39;partner_id&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_onchange_partner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Dear </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partner_id</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >В представлении в виде формы где появляется поле, метод вызывается, когда одно из заданных полей изменяется. Метод вызывается в псевдо-записи, содержащей значения, присутствующие в форме. Назначения полей в этой записи автоматически отправляются обратно клиенту.</p><p >Метод может возвращать словарь для изменения полей домена и выводить предупреждающее сообщение, как в старом API:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="p">{</span>
    <span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;other_id&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;partner_id&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">partner_id</span><span class="p">)]},</span>
    <span class="s1">&#39;warning&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s2">&quot;Warning&quot;</span><span class="p">,</span> <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="s2">&quot;What is this?&quot;</span><span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<div role="alert" class="alert-warning alert"><h3 class="alert-title">Предупреждение</h3><p ><code >@onchange</code> поддерживает только простые имена полей, имена с точками (поля реляционных полей, например <code >partner_id.tz</code>) не поддерживаются и будут игнорироваться</p></div></section><section class="code-function"><h6 id="odoo.api.returns"><code>odoo.api.returns(<em>model</em>, <em>downgrade=None</em>, <em>upgrade=None</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/api.py#L226" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает декоратор для методов, возвращающих экземпляры <code >model</code>.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >model</strong> -- наименование модели данных или <code >'self'</code> для текущей модели данных</li><li ><strong >downgrade</strong> -- функция <code >downgrade(self, value, *args, **kwargs)</code> для преобразования нового стиля <code >value</code> в старый</li><li ><strong >upgrade</strong> -- функция <code >upgrade(self, value, *args, **kwargs)</code> для преобразования из старого стиля <code >value</code> в новый</li></ul></div></div></div><p >Аргументы <code >self</code>, <code >*args</code> и <code >kwargs</code> - это параметры, которые передаются методу в новом стиле.</p><p >Декоратор приспосабливает вывод метода к стилю API: <code >id</code>, <code >ids</code> или <code >False</code> для старого стиля и НЗ для нового:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@model</span>
<span class="nd">@returns</span><span class="p">(</span><span class="s1">&#39;res.partner&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">find_partner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>     <span class="c1"># return some record</span>

<span class="c1"># output depends on call style: traditional vs record style</span>
<span class="n">partner_id</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">find_partner</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>

<span class="c1"># recs = model.browse(cr, uid, ids, context)</span>
<span class="n">partner_record</span> <span class="o">=</span> <span class="n">recs</span><span class="o">.</span><span class="n">find_partner</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</pre></div>
</div>
<p >Обратите внимание, что декорированный метод должен удовлетворять этому соглашению.</p><p >Эти декораторы автоматически <em >наследуются</em>: метод, который переопределяет декорированный существующий метод, будет задекорирован тем же <code >@returns(model)</code>.</p></section><section class="code-function"><h6 id="odoo.api.one"><code>odoo.api.one(<em>method</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/api.py#L341" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Задекорируйте метод нового стиля, где <code >self</code> должен быть ОЗ экземпляром. Декорированный метод автоматически перебирает записи и составляет список с результатами. Если метод задекорирован <a href="#odoo.api.returns" class="internal alert-link reference" title="odoo.api.returns"><code class="py xref py-func">returns()</code></a>, он складывает результирующие экземпляры. Таким способом:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">one</span>
<span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p >может быть вызван как в старом, так и в новом стиле, например:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># recs = model.browse(cr, uid, ids, context)</span>
<span class="n">names</span> <span class="o">=</span> <span class="n">recs</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="n">names</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
<div class="deprecated"><p ><span class="versionmodified">Не рекомендуется, начиная с версии 9.0: </span><a href="#odoo.api.one" class="internal alert-link reference" title="odoo.api.one"><code class="py xref py-func">one()</code></a> часто делает код менее понятным и ведет себя так, как могут не ожидать разработчики и читатели.</p><p >Настоятельно рекомендуется использовать <a href="#odoo.api.multi" class="internal alert-link reference" title="odoo.api.multi"><code class="py xref py-func">multi()</code></a> и либо выполнить итерацию по НЗ через <code >self</code>, либо убедиться, что НЗ является одной записью с <a href="#odoo.models.Model.ensure_one" class="internal alert-link reference" title="odoo.models.Model.ensure_one"><code class="py py-meth xref">ensure_one()</code></a>.</p></div></section><section class="code-function"><h6 id="odoo.api.v7"><code>odoo.api.v7(<em>method_v7</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/api.py#L556" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Задекорируйте метод, который поддерживает только api в старом стиле. Новый API-интерфейс может быть предоставлен переопределением метода с тем же именем и декоратором <a href="#odoo.api.v8" class="internal alert-link reference" title="odoo.api.v8"><code class="py xref py-func">v8()</code></a>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">v7</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>

<span class="nd">@api</span><span class="o">.</span><span class="n">v8</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p >Особую осторожность следует проявлять, если один метод вызывает другой, потому что метод может быть переопределен! В этом случае следует вызвать метод из текущего класса (скажем, <code >MyClass</code>), например</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">v7</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Beware: records.foo() may call an overriding of foo()</span>
    <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>
</pre></div>
</div>
<p >Обратите внимание, что метод-враппер использует docstring первого метода.</p></section><section class="code-function"><h6 id="odoo.api.v8"><code>odoo.api.v8(<em>method_v8</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/api.py#L586" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Задекорируйте метод, который поддерживает только API-интерфейс нового стиля. Для api старого стиля можно переопределить метод с тем же именем и задекорировать его <a href="#odoo.api.v7" class="internal alert-link reference" title="odoo.api.v7"><code class="py xref py-func">v7()</code></a>:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">v8</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

<span class="nd">@api</span><span class="o">.</span><span class="n">v7</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p >Обратите внимание, что метод-враппер использует docstring первого метода.</p></section></section><section id="fields"><i id="reference-orm-fields"></i><h2 >Поля</h2></section><section id="basic-fields"><i id="reference-orm-fields-basic"></i><h3 >Основные поля</h3><section class="code-class"><h6 id="odoo.fields.Field"><code><em >class </em>odoo.fields.Field(<em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L100" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Дескриптор поля содержит определение поля и управляет доступом и присвоением соответствующего поля для записей. При инициализации поля могут быть предоставлены следующие атрибуты:</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >string</strong> -- Метка поля, видимая пользователями (строка); Если не установлено, ORM берет имя поля в классе (с заглавной буквы).</li><li ><strong >help</strong> -- Всплывающая подсказка поля, видимая пользователями (строка)</li><li ><strong >readonly</strong> -- Является ли поле readonly (логическим, по умолчанию `` False``)</li><li ><strong >required</strong> -- Требуется ли значение поля (логическое значение, по умолчанию `` Ложное_`)</li><li ><strong >index</strong> -- Является ли поле индексированным в базе данных (логическое, по умолчанию `` Ложное``)</li><li ><strong >default</strong> -- Значение по умолчанию для поля; Это либо статическое значение, либо функция, выполняющая набор записей и возвращающая значение; Используйте `` default = None``, чтобы сбросить значения по умолчанию для поля</li><li ><strong >states</strong> -- Словарь значений состояния отображения в списки пар атрибут-значение пользовательского интерфейса; Возможные атрибуты: «readonly», «required», «invisible». Примечание. Любое состояние на основе состояния требует, чтобы в пользовательском интерфейсе клиентской стороны было доступно значение поля `` состояние``. Обычно это делается путем включения его в соответствующие представления, возможно сделанные невидимыми, если это не относится к конечному пользователю.</li><li ><strong >groups</strong> -- Список групповых xml-идентификаторов (строка), разделённых запятыми; Это ограничивает доступ к полям только для пользователей указанных групп</li><li ><strong >copy</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" class="external reference alert-link" title="(в Python v3.7)"><code >bool</code></a>) -- Следует ли копировать значение поля при дублировании записи (по умолчанию: `` True`` для обычных полей, `` False`` для `` one2many`` и вычисляемых полей, включая поля свойств и связанные поля)</li><li ><strong >oldname</strong> (<a href="https://docs.python.org/3/library/string.html#module-string" class="external reference alert-link" title="(в Python v3.7)"><code >string</code></a>) -- Предыдущее имя этого поля, чтобы ORM мог автоматически переименовать его при миграции</li></ul></div></div></div><h4 id="field-computed">Вычисляемые поля</h4><p >Можно определить поле, значение которого вычисляется вместо простого чтения из базы данных. Атрибуты, специфичные для вычисляемых полей, приведены ниже. Чтобы определить такое поле, просто укажите значение атрибута `` compute``.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >compute</strong> -- Имя метода, который вычисляет поле</li><li ><strong >inverse</strong> -- Имя метода, который инвертирует поле (необязательно)</li><li ><strong >search</strong> -- Имя метода, реализующего поиск по полю (необязательно)</li><li ><strong >store</strong> -- Хранится ли поле в базе данных (логическое значение, по умолчанию `` Ложное`` в вычисленных полях)</li><li ><strong >compute_sudo</strong> -- Должно ли поле быть пересчитано в качестве суперпользователя для обхода прав доступа (логическое, по умолчанию `` False``)</li></ul></div></div></div><p >Методы, приведенные для `` compute``, `` inverse`` и `` search``, являются модельными методами. Их подпись показана в следующем примере</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">upper</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s1">&#39;_compute_upper&#39;</span><span class="p">,</span>
                    <span class="n">inverse</span><span class="o">=</span><span class="s1">&#39;_inverse_upper&#39;</span><span class="p">,</span>
                    <span class="n">search</span><span class="o">=</span><span class="s1">&#39;_search_upper&#39;</span><span class="p">)</span>

<span class="nd">@api</span><span class="o">.</span><span class="n">depends</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_compute_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">rec</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_inverse_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">rec</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">upper</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">upper</span> <span class="k">else</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_search_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;like&#39;</span><span class="p">:</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="s1">&#39;ilike&#39;</span>
    <span class="k">return</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">value</span><span class="p">)]</span>
</pre></div>
</div>
<p >Метод compute должен назначить поле для всех записей набора записей. Декоратор: meth: <code >odoo.api.depends</code> должен быть применен к методу compute для указания зависимостей полей; Эти зависимости используются, чтобы определить, когда нужно пересчитывать поле; Пересчет является автоматическим и гарантирует согласованность кэша / базы данных. Обратите внимание, что один и тот же метод может использоваться для нескольких полей, вам просто нужно назначить все указанные поля в методе; Метод будет вызываться один раз для всех этих полей.</p><p >По умолчанию вычисленное поле не сохраняется в базе данных и вычисляется «на лету». Добавление атрибута `` store = True`` будет хранить значения поля в базе данных. Преимущество хранимого поля в том, что поиск по этому полю выполняется самой базой данных. Недостатком является то, что для обновления необходимо обновить базу данных.</p><p >Обратный метод, как следует из его имени, делает инверсию метода compute: вызванные записи имеют значение для поля, и вы должны применять необходимые изменения для зависимостей полей, чтобы вычисление давало ожидаемое значение. Обратите внимание, что вычисляемое поле без обратного метода по умолчанию доступно только для чтения.</p><p >Метод поиска вызывается при обработке доменов перед выполнением фактического поиска по модели. Он должен возвращать домен, эквивалентный условию: `` значение оператора поля``.</p><h4 id="field-related">Реляционные поля</h4><p >Значение связанного поля задается последовательностью реляционных полей и чтением поля по достигнутой модели. Полная последовательность полей для перемещения определяется атрибутом</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >related</strong> -- Последовательность имен полей</div></div></div><p >Некоторые атрибуты полей автоматически копируются из исходного поля, если они не переопределены: `` строка``, `` help``, `` readonly``, `` required`` (только если все поля в последовательности обязательны) , `` Группы``, <code >цифры'</code>,` <code >размер`</code>,` <code >переводить`</code>,` <code >санировать``</code>,` <code >выбор`</code>,` <code >comodel_name`</code>,` <code >домен`</code>,` <code >context`</code>. Все семантически-свободные атрибуты копируются из исходного поля.</p><p >По умолчанию значения связанных полей не сохраняются в базе данных. Добавьте атрибут `` store = True``, чтобы он сохранялся, как и вычисляемые поля. Связанные поля автоматически пересчитываются при изменении их зависимостей.</p><h4 id="field-company-dependent">Зависимые от компании поля</h4><p >Ранее известные как поля свойств, значение этих полей зависит от компании. Другими словами, пользователи, принадлежащие к разным компаниям, могут видеть разные значения поля для данной записи.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >company_dependent</strong> -- Является ли поле зависимым от компании (булево)</div></div></div><h4 id="field-incremental-definition">Пошаговое определение</h4><p >Поле определяется как атрибут класса в классе модели. Если модель расширена (см.: Класс: <code >~ odoo.models.Model</code>), можно также расширить определение поля, переопределив поле под тем же именем и тем же типом в подклассе. В этом случае атрибуты поля берутся из родительского класса и переопределяются атрибутами, указанными в подклассах.</p><p >Например, второй класс ниже только добавляет всплывающую подсказку в поле `` state``</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">First</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Selection</span><span class="p">([</span><span class="o">...</span><span class="p">],</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Second</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_inherit</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Selection</span><span class="p">(</span><span class="n">help</span><span class="o">=</span><span class="s2">&quot;Blah blah blah&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section><section class="code-class"><h6 id="odoo.fields.Char"><code><em >class </em>odoo.fields.Char(<em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1352" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields._String</code></p><p >Поле основной строки может быть ограничено по длине, обычно отображается в виде строки с одной строкой в ​​клиентах.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" class="external reference alert-link" title="(в Python v3.7)"><code >int</code></a>) -- Максимальный размер значений, хранящихся для этого поля</li><li ><strong >translate</strong> -- Включить перевод значений поля; Используйте `` translate = True`` для перевода значений полей в целом; `` Translate`` также может быть вызываемым, так что <code >translate (callback, value)</code> <code >переводит</code> <code >значение`</code> с помощью` <code >callback (term)</code> [UNKNOWN NODE problematic], чтобы получить перевод терминов.</li></ul></div></div></div></section><section class="code-class"><h6 id="odoo.fields.Boolean"><code><em >class </em>odoo.fields.Boolean(<em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1119" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields.Field</code></p></section><section class="code-class"><h6 id="odoo.fields.Integer"><code><em >class </em>odoo.fields.Integer(<em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1135" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields.Field</code></p></section><section class="code-class"><h6 id="odoo.fields.Float"><code><em >class </em>odoo.fields.Float(<em>string=&lt;object object&gt;</em>, <em>digits=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1172" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields.Field</code></p><p >Цифры точности задаются атрибутом</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >digits</strong> -- Пара (total, decimal) или функция, берущая курсор базы данных и возвращающая пару (total, decimal)</div></div></div></section><section class="code-class"><h6 id="odoo.fields.Text"><code><em >class </em>odoo.fields.Text(<em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1404" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields._String</code></p><p >Очень похоже на: class: <code >~ .Char</code>, но используется для более длинного содержимого, не имеет размера и обычно отображается как многострочное текстовое поле.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >translate</strong> -- Включить перевод значений поля; Используйте `` translate = True`` для перевода значений полей в целом; `` Translate`` также может быть вызываемым, так что <code >translate (callback, value)</code> <code >переводит</code> <code >значение`</code> с помощью` <code >callback (term)</code> [UNKNOWN NODE problematic], чтобы получить перевод терминов.</div></div></div></section><section class="code-class"><h6 id="odoo.fields.Selection"><code><em >class </em>odoo.fields.Selection(<em>selection=&lt;object object&gt;</em>, <em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1719" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields.Field</code></p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >selection</strong> -- Указывает возможные значения для этого поля. Он задается либо как список пар («значение», «строка»), либо как модельный метод, либо как имя метода.</li><li ><strong >selection_add</strong> -- Предоставляет расширение выбора в случае переопределенного поля. Это список пар (`` значение``, `` строка``).</li></ul></div></div></div><p >Атрибут `` selection`` является обязательным, за исключением случая: ref: <code >related fields &lt;field-related&gt;</code> или: ref: <code >field extensions &lt;field-incremental-definition&gt;</code>.</p></section><section class="code-class"><h6 id="odoo.fields.Html"><code><em >class </em>odoo.fields.Html(<em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1424" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields._String</code></p></section><section class="code-class"><h6 id="odoo.fields.Date"><code><em >class </em>odoo.fields.Date(<em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1483" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields.Field</code></p><section class="code-staticmethod"><h6 id="odoo.fields.Date.context_today"><code><em >static </em>context_today(<em>record</em>, <em>timestamp=None</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1495" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает текущую дату в часовом поясе клиента в формате, соответствующем полям даты. Этот метод может использоваться для вычисления значений по умолчанию.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >timestamp</strong> (<a href="https://docs.python.org/3/library/datetime.html#module-datetime" class="external reference alert-link" title="(в Python v3.7)"><code >datetime</code></a>) -- Необязательное значение datetime для использования вместо текущей даты и времени (должно быть datetime, регулярные даты не могут быть преобразованы между часовыми поясами).</div></div><div class="code-field"><div class="code-field-name">Тип результата</div><div class="code-field-body"><a href="https://docs.python.org/3/library/stdtypes.html#str" class="external reference alert-link" title="(в Python v3.7)">str</a></div></div></div></section><section class="code-staticmethod"><h6 id="odoo.fields.Date.from_string"><code><em >static </em>from_string(<em>value</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1518" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Преобразуйте значение ORM `` значение`` в значение: class: <code >date</code>.</p></section><section class="code-staticmethod"><h6 id="odoo.fields.Date.to_string"><code><em >static </em>to_string(<em>value</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1526" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Преобразовать a: class: значение <code >date</code> в формат, ожидаемый ORM.</p></section><section class="code-staticmethod"><h6 id="odoo.fields.Date.today"><code><em >static </em>today(<em>*args</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1488" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает текущий день в формате, ожидаемом ORM. Эта функция может использоваться для вычисления значений по умолчанию.</p></section></section><section class="code-class"><h6 id="odoo.fields.Datetime"><code><em >class </em>odoo.fields.Datetime(<em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1550" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields.Field</code></p><section class="code-staticmethod"><h6 id="odoo.fields.Datetime.context_timestamp"><code><em >static </em>context_timestamp(<em>record</em>, <em>timestamp</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1562" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает заданную временную метку, преобразованную в часовой пояс клиента. Этот метод * не * предназначен для использования в качестве инициализатора по умолчанию, поскольку поля даты и времени автоматически преобразуются при отображении на стороне клиента. Для значений по умолчанию: meth: <code >fields.datetime.now</code> следует использовать вместо этого.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >timestamp</strong> (<a href="https://docs.python.org/3/library/datetime.html#module-datetime" class="external reference alert-link" title="(в Python v3.7)"><code >datetime</code></a>) -- Наивное значение даты и времени (выраженное в формате UTC), которое должно быть преобразовано в часовой пояс клиента</div></div><div class="code-field"><div class="code-field-name">Тип результата</div><div class="code-field-body"><a href="https://docs.python.org/3/library/datetime.html#module-datetime" class="external reference alert-link" title="(в Python v3.7)">datetime</a></div></div><div class="code-field"><div class="code-field-name">Результат</div><div class="code-field-body">Временная метка, преобразованная в datetime с учетом часового пояса в контексте часового пояса</div></div></div></section><section class="code-staticmethod"><h6 id="odoo.fields.Datetime.from_string"><code><em >static </em>from_string(<em>value</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1589" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Преобразуйте значение ORM в значение: class: <code >datetime</code>.</p></section><section class="code-staticmethod"><h6 id="odoo.fields.Datetime.now"><code><em >static </em>now(<em>*args</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1555" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Возвращает текущий день и время в формате, ожидаемом ORM. Эта функция может использоваться для вычисления значений по умолчанию.</p></section><section class="code-staticmethod"><h6 id="odoo.fields.Datetime.to_string"><code><em >static </em>to_string(<em>value</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1599" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Преобразуйте значение типа: datetime в формат, ожидаемый ORM.</p></section></section></section><section id="relational-fields"><i id="reference-orm-fields-relational"></i><h3 >Реляционные поля</h3><section class="code-class"><h6 id="odoo.fields.Many2one"><code><em >class </em>odoo.fields.Many2one(<em>comodel_name=&lt;object object&gt;</em>, <em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1894" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields._Relational</code></p><p >Значение такого поля - это набор записей размера 0 (нет записи) или 1 (одна запись).</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >comodel_name</strong> -- Имя целевой модели (строка)</li><li ><strong >domain</strong> -- Необязательный домен для установки значений кандидатов на стороне клиента (домен или строка)</li><li ><strong >context</strong> -- Необязательный контекст для использования на стороне клиента при обработке этого поля (словаря)</li><li ><strong >ondelete</strong> -- Что делать, если упомянутая запись удалена; Возможные значения: `` 'set null```, <code >' restrict'</code>, `` 'cascade'[UNKNOWN NODE problematic][UNKNOWN NODE problematic]</li><li ><strong >auto_join</strong> -- Генерируются ли JOIN при поиске в этом поле (логическое значение, по умолчанию `` False``)</li><li ><strong >delegate</strong> -- Установите его в `` True``, чтобы сделать поля целевой модели доступными из текущей модели (соответствует `` _inherits``)</li></ul></div></div></div><p >Атрибут `` comodel_name`` является обязательным, за исключением случаев, касающихся связанных полей или расширений полей.</p></section><section class="code-class"><h6 id="odoo.fields.One2many"><code><em >class </em>odoo.fields.One2many(<em>comodel_name=&lt;object object&gt;</em>, <em>inverse_name=&lt;object object&gt;</em>, <em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L2165" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields._RelationalMulti</code></p><p >Поле One2many; Значение такого поля является набором записей всех записей в `` comodel_name``, так что поле `` inverse_name`` равно текущей записи.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >comodel_name</strong> -- Имя целевой модели (строка)</li><li ><strong >inverse_name</strong> -- Имя инверсного поля `` Many2one`` в `` comodel_name`` (строка)</li><li ><strong >domain</strong> -- Необязательный домен для установки значений кандидатов на стороне клиента (домен или строка)</li><li ><strong >context</strong> -- Необязательный контекст для использования на стороне клиента при обработке этого поля (словаря)</li><li ><strong >auto_join</strong> -- Генерируются ли JOIN при поиске в этом поле (логическое значение, по умолчанию `` False``)</li><li ><strong >limit</strong> -- Необязательное ограничение на чтение (целое)</li></ul></div></div></div><p >Атрибуты `` comodel_name`` и `` inverse_name`` обязательны, за исключением соответствующих полей или расширений полей.</p></section><section class="code-class"><h6 id="odoo.fields.Many2many"><code><em >class </em>odoo.fields.Many2many(<em>comodel_name=&lt;object object&gt;</em>, <em>relation=&lt;object object&gt;</em>, <em>column1=&lt;object object&gt;</em>, <em>column2=&lt;object object&gt;</em>, <em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L2297" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields._RelationalMulti</code></p><p >Поле Many2many; Значением такого поля является набор записей.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><strong >comodel_name</strong> -- Имя целевой модели (строка)</div></div></div><p >Атрибут `` comodel_name`` является обязательным, за исключением случаев, касающихся связанных полей или расширений полей.</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >relation</strong> -- Необязательное имя таблицы, в которой хранится отношение в базе данных (строка)</li><li ><strong >column1</strong> -- Необязательное имя столбца, ссылающееся на &quot;эти&quot; записи в таблице <code >relation</code> (строка)</li><li ><strong >column2</strong> -- Необязательное имя столбца, ссылающегося на &quot;те&quot; записи в таблице <code >relation</code> (строка)</li></ul></div></div></div><p >Атрибуты `` отношение``, `` column1`` и `` column2`` являются необязательными. Если не указано, имена автоматически генерируются из имен моделей, если <code >model_name`</code> и` <code >comodel_name`</code> различны!</p><div class="code-fields"><div class="code-field"><div class="code-field-name">Параметры</div><div class="code-field-body"><ul ><li ><strong >domain</strong> -- Необязательный домен для установки значений кандидатов на стороне клиента (домен или строка)</li><li ><strong >context</strong> -- Необязательный контекст для использования на стороне клиента при обработке этого поля (словаря)</li><li ><strong >limit</strong> -- Необязательное ограничение на чтение (целое)</li></ul></div></div></div></section><section class="code-class"><h6 id="odoo.fields.Reference"><code><em >class </em>odoo.fields.Reference(<em>selection=&lt;object object&gt;</em>, <em>string=&lt;object object&gt;</em>, <em>**kwargs</em>)<a href="https://github.com/odoo/odoo/blob/11.0/odoo/fields.py#L1820" class="external reference alert-link"><span class="viewcode-link">[исходный код]</span></a></code></h6><p >Базовые классы:: class: <code >odoo.fields.Selection</code></p></section></section><section id="inheritance-and-extension"><i id="reference-orm-inheritance"></i><h2 >Наследование и расширение</h2><p >Odoo обеспечивает три различных механизма для расширения моделей данных по модульному принципу:</p><ul ><li ><p >создание новой модели данных из уже существующей, добавляя новую информацию в копию, но оставляя исходный модуль как есть</p></li><li ><p >расширение моделей данных, определенных в других модулях, заменяя предыдующую версию</p></li><li ><p >делегировании некоторых полей моделей данных к записям, которые они содержат</p></li></ul><img src="../_images/inheritance_methods1.png" class="img-responsive center-block"></section><section id="classical-inheritance"><h3 >Классическое наследование</h3><p >При использовании атрибутов <a href="#odoo.models.Model._inherit" class="internal reference" title="odoo.models.Model._inherit"><code class="py xref py-attr">_inherit</code></a> и <a href="#odoo.models.Model._name" class="internal reference" title="odoo.models.Model._name"><code class="py xref py-attr">_name</code></a> вместе, Odoo создает новую модель, используя уже существующую (с помощью атрибута : attr: <code >~ Odoo.models.Model._inherit</code>) в качестве базиса. Новая модель получает все поля, методы и мета-информацию (defaults &amp; al) от базисной модели данных.</p><div class="highlight-python"><div class="highlight"><pre><span></span>
<span class="k">class</span> <span class="nc">Inheritance0</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;inheritance.0&#39;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">&quot;model 0&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;This is {} record {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Inheritance1</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;inheritance.1&#39;</span>
    <span class="n">_inherit</span> <span class="o">=</span> <span class="s1">&#39;inheritance.0&#39;</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">&quot;model 1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >и их использование:</p><div class="highlight-python"><div class="highlight"><pre><span></span>        <span class="n">a</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;inheritance.0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">})</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;inheritance.1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;B&#39;</span><span class="p">})</span>
            <span class="n">a</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
            <span class="n">b</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>
</pre></div>
</div>
<p >даст следующий результат:</p><div class="highlight-text"><div class="highlight"><pre><span></span>            &quot;This is model 0 record A&quot;
            &quot;This is model 1 record B&quot;
</pre></div>
</div>
<p >вторая модель данных унаследовала от первой метод проверки <code >check</code> и ее поле <code >name</code>, но переопределила метод <code >call</code>, как при использовании стандартного <span class="std xref std-ref">механизма наследования Python</span>.</p></section><section id="extension"><h3 >Расширение</h3><p >При использовании <a href="#odoo.models.Model._inherit" class="internal reference" title="odoo.models.Model._inherit"><code class="py xref py-attr">_inherit</code></a>, но не учитывая <a href="#odoo.models.Model._name" class="internal reference" title="odoo.models.Model._name"><code class="py xref py-attr">_name</code></a>,  новая модель данных заменит собой уже существующую, расширяя ее. Это полезно для добавления новых полей или методов в существующие модели данных (созданные в других модулях), или их индивидуальной настройки (например, чтобы изменить их порядок сортировки по умолчанию):</p><div class="highlight-python"><div class="highlight"><pre><span></span>
<span class="k">class</span> <span class="nc">Extension0</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;extension.0&#39;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Extension1</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_inherit</span> <span class="o">=</span> <span class="s1">&#39;extension.0&#39;</span>

    <span class="n">description</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s2">&quot;Extended&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>        <span class="n">env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span>
        <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s2">&quot;Extended&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p >даст следующий результат:</p><div class="highlight-text"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div role="alert" class="alert-info alert"><h3 class="alert-title">Примечание</h3><p >это приведет к <a href="#reference-orm-model-automatic" class="internal alert-link reference"><span class="std std-ref">автомтически созданным полям</span></a>, если они не были отключены</p></div></section><section id="delegation"><h3 >Делегирование</h3><p >Третий механизм наследования обеспечивает большую гибкость (существует возможность изменения во врмемя выполнения) но требует больше мощностей: использу <a href="#odoo.models.Model._inherits" class="internal reference" title="odoo.models.Model._inherits"><code class="py xref py-attr">_inherits</code></a> модель данных <em >делегирует</em> поиск любого поля, не найденного в текущей модели данных &quot;дочерним&quot; моделям данных. Делегирование осуществляется с помощью <a href="#odoo.fields.Reference" class="internal reference" title="odoo.fields.Reference"><code class="py xref py-class">Reference</code></a>, полей автомтически установленных на родительской модели данных:</p><div class="highlight-python"><div class="highlight"><pre><span></span>
<span class="k">class</span> <span class="nc">Child0</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;delegation.child0&#39;</span>

    <span class="n">field_0</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Integer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Child1</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;delegation.child1&#39;</span>

    <span class="n">field_1</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Integer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Delegating</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;delegation.parent&#39;</span>

    <span class="n">_inherits</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;delegation.child0&#39;</span><span class="p">:</span> <span class="s1">&#39;child0_id&#39;</span><span class="p">,</span>
        <span class="s1">&#39;delegation.child1&#39;</span><span class="p">:</span> <span class="s1">&#39;child1_id&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">child0_id</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Many2one</span><span class="p">(</span><span class="s1">&#39;delegation.child0&#39;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ondelete</span><span class="o">=</span><span class="s1">&#39;cascade&#39;</span><span class="p">)</span>
    <span class="n">child1_id</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Many2one</span><span class="p">(</span><span class="s1">&#39;delegation.child1&#39;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ondelete</span><span class="o">=</span><span class="s1">&#39;cascade&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span>        <span class="n">record</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;delegation.parent&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">({</span>
            <span class="s1">&#39;child0_id&#39;</span><span class="p">:</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;delegation.child0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">({</span><span class="s1">&#39;field_0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="s1">&#39;child1_id&#39;</span><span class="p">:</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;delegation.child1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">({</span><span class="s1">&#39;field_1&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="p">})</span>
            <span class="n">record</span><span class="o">.</span><span class="n">field_0</span>
            <span class="n">record</span><span class="o">.</span><span class="n">field_1</span>
</pre></div>
</div>
<p >даст результат:</p><div class="highlight-text"><div class="highlight"><pre><span></span>            0
            1
</pre></div>
</div>
<p >есть возможность сделать запись прямо в делегированное поле:</p><div class="highlight-python"><div class="highlight"><pre><span></span>        <span class="n">record</span><span class="o">.</span><span class="n">write</span><span class="p">({</span><span class="s1">&#39;field_1&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span>
</pre></div>
</div>
<div role="alert" class="alert-warning alert"><h3 class="alert-title">Предупреждение</h3><p >когда используете наследование через делегирование, <em >методы не наследуются</em>, только поля</p></div></section><section id="domains"><i id="reference-orm-domains"></i><h2 >Домены</h2><p >Домен - это список критериев, каждый критерий состоит из трех частей ( является либо <code >списком</code> или <code >кортежем</code>) <code >(имя_поля, оператор, значние)</code> где:</p><dl ><dt ><code >имя_поля</code> (<code >str</code>)</dt><dd ><p >имя поля текущей модели или отношение через класс <a href="#odoo.fields.Many2one" class="internal reference" title="odoo.fields.Many2one"><code class="py xref py-class">Many2one</code></a> с использованием dot-нотации, например <code >'street'</code> или <code >'partner_id.country'</code></p></dd><dt ><code >operator</code> (<code >str</code>)</dt><dd ><p >оператор, используемый для сравнения <code >имя_поля</code> со <code >значением</code>. Допустимые операторы:</p><dl ><dt ><code >=</code></dt><dd ><p >равно</p></dd><dt ><code >!=</code></dt><dd ><p >не равно</p></dd><dt ><code >&gt;</code></dt><dd ><p >больше чем</p></dd><dt ><code >&gt;=</code></dt><dd ><p >больше чем или равно</p></dd><dt ><code >&lt;</code></dt><dd ><p >меньше чем</p></dd><dt ><code >&lt;=</code></dt><dd ><p >меньше чем или равно</p></dd><dt ><code >=?</code></dt><dd ><p >не задано или равно (возварщает true если <code >значение</code> является либо``None`` или <code >False</code>, в противном случае ведет себя как <code >=</code>)</p></dd><dt ><code >=like</code></dt><dd ><p >сопоставляет <code >имя_поля</code> с шаблоном <code >значения</code>. Подчеркивание <code >_</code> в шаблоне означает (соответствует) любому одиночному символу; знак процента <code >%</code> соответствует любой строке из нуля или более символов.</p></dd><dt ><code >like</code></dt><dd ><p >сопоставляет <code >имя_поля</code> с шаблоном <code >%значения%</code>. Так же как <code >=like</code>, но оборачивает <code >значение</code> в <code >%</code> перед сравнением</p></dd><dt ><code >not like</code></dt><dd ><p >не сопоставляет с шаблоном <code >%value%</code></p></dd><dt ><code >ilike</code></dt><dd ><p >не чувтсвительный к регистру <code >like</code></p></dd><dt ><code >not ilike</code></dt><dd ><p >не чувствительный к регистру <code >not like</code></p></dd><dt ><code >=ilike</code></dt><dd ><p >не чувтсвительный к регистру <code >=like</code></p></dd><dt ><code >in</code></dt><dd ><p >равно любому из элементов <code >значения</code>, `` значение`` должно быть списком элементов</p></dd><dt ><code >not in</code></dt><dd ><p >не равно любому из элементов <code >значения</code></p></dd><dt ><code >child_of</code></dt><dd ><p >дочернее значение (потомок) <code >value</code> записи.</p><p >Принимает во внимание семантику модели данных (т. е. за следующий реляционным полем , с наименованием <code class="py xref py-attr">_parent_name</code>).</p></dd></dl></dd><dt ><code >value</code></dt><dd ><p >тип переменной, который должен быть сопоставим (через <code >operator</code>) с названным полем</p></dd></dl><p >Критерии домена могут быть объединены с помощью логических операторов в виде <em >prefix</em>:</p><dl ><dt ><code >'&amp;'</code></dt><dd ><p >логическое <em >И</em>, операция по умолчанию для объединения критериев, следующих друг за другом. Arity 2 (испольузет следующие 2 кртерия или комбинации).</p></dd><dt ><code >'|'</code></dt><dd ><p >логическое <em >ИЛИ</em>, arity 2.</p></dd><dt ><code >'!'</code></dt><dd ><p >Логическое <em >НЕ</em>, arity 1.</p><div role="alert" class="alert-info aphorism alert"><h3 class="alert-title">Совет</h3><p >Главным образом, чтобы свести на нет комбинации критериев</p><p >Индивидуальный критерий как правило, имеет отрицательную форму(например: <code >=</code> -&gt; <code >!=</code>, <code >&lt;</code> -&gt; <code >&gt;=</code>), что является более простым способом достичь нужного результата, чем отрицание положительных результатов .</p></div></dd></dl><div role="alert" class="admonition-example alert"><h3 class="alert-title">Пример</h3><p >Для поиска партнера с именем <em >ABC</em>, из Бельгии или Германии, чей язык не английский:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="s1">&#39;=&#39;</span><span class="p">,</span><span class="s1">&#39;ABC&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;language.code&#39;</span><span class="p">,</span><span class="s1">&#39;!=&#39;</span><span class="p">,</span><span class="s1">&#39;en_US&#39;</span><span class="p">),</span>
 <span class="s1">&#39;|&#39;</span><span class="p">,(</span><span class="s1">&#39;country_id.code&#39;</span><span class="p">,</span><span class="s1">&#39;=&#39;</span><span class="p">,</span><span class="s1">&#39;be&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;country_id.code&#39;</span><span class="p">,</span><span class="s1">&#39;=&#39;</span><span class="p">,</span><span class="s1">&#39;de&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p >Этот домен интерпретируется как:</p><div class="highlight-text"><div class="highlight"><pre><span></span>    (name is &#39;ABC&#39;)
AND (language is NOT english)
AND (country is Belgium OR Germany)
</pre></div>
</div>
</div></section><section id="porting-from-the-old-api-to-the-new-api"><h2 >Портирование со старого API на новый API</h2><ul ><li ><p >в новом API необходимо исключить списки идентификаторов, вместо этого использовать НЗ</p></li><li ><p >методы, все еще написанные на старом API, должны автоматически работать с ORM, отсутствует необходимость переключения на старый API, просто вызывайте их, как если бы они были методом нового API. Смотрите <a href="#reference-orm-oldapi-bridging" class="internal reference"><span class="std std-ref">Автоматический проброс старых API-методов</span></a> для более подробной информации.</p></li><li ><p ><a href="#odoo.models.Model.search" class="internal reference" title="odoo.models.Model.search"><code class="py py-meth xref">search()</code></a> возвращает НЗ, не имеет смысла, например, при просмотре его результата</p></li><li ><p ><code >fields.related</code> и <code >fields.function</code> заменяются с использованием нормального типа поля с параметром <code >related=</code> или <code >compute=</code></p></li><li ><p >функции <a href="#odoo.api.depends" class="internal reference" title="odoo.api.depends"><code class="py xref py-func">depends()</code></a> в <code >compute=</code> методах <strong >должны быть полными</strong>, они должны отобразить <strong >все</strong> поляполя, которые использует метод для вычисления. Лучше иметь слишком много зависимостей (будет пересчитывать поле в тех случаях, когда это не требуется), чем недостаточное их количество (забудет пересчитать поле, в следствии чего значения будут неверны)</p></li><li ><p ><strong >удалить</strong> все методы <code >onchange</code> для вычисляемых полей. Вычисляемые поля автоматически пересчитываются при изменении значения одного из полей, указанных в зависимостях и используются для автоматической генерации <code >onchange</code> клиентом</p></li><li ><p >декораторы <a href="#odoo.api.model" class="internal reference" title="odoo.api.model"><code class="py xref py-func">model()</code></a> и <a href="#odoo.api.multi" class="internal reference" title="odoo.api.multi"><code class="py xref py-func">multi()</code></a> предназначены для объединения <em >при вызове из контекста старого API</em>, для внутренних или простых методов нового API (например, compute) они бесполезны</p></li><li ><p >замените <code class="py xref py-attr">_default</code>, замените параметром <code >default=</code> в соответствующих полях</p></li><li ><p >если параметр поля <code >string=</code> - это наименование поля с большой буквы:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s2">&quot;Name&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >он бесполезен и должен быть удален</p></li><li ><p >параметр <code >multi=</code> ничего не делает в полях в новом API, он использует одни и те же методы что и <code >compute=</code> во всех соответствующих полях для достижения одного и того же результата</p></li><li ><p >предоставляет <code >compute=</code>, <code >inverse=</code> и <code >search=</code> методы по имени (как строку), это делает их переопределяемыми (устраняет необходимость в промежуточной функции &quot;трамплине&quot;)</p></li><li ><p >дважды проверьте, что все поля и методы имеют разные имена, в случае совпадения их имен предупреждение будет отсутствовать (поскольку Python обрабатывает его до того, как Odoo увидит что-либо)</p></li><li ><p >нормальный импорт для нового API <code >from odoo import fields, models</code>. Если необходимы декораторы совместимости, используйте <code >from odoo import api, fields, models</code>.</p></li><li ><p >избегайте <a href="#odoo.api.one" class="internal reference" title="odoo.api.one"><code class="py xref py-func">one()</code></a> декоратор, он, вероятно, не делает то, что вы ожидаете</p></li><li ><p >Удалите явное определение полей <a href="#odoo.models.Model.create_uid" class="internal reference" title="odoo.models.Model.create_uid"><code class="py xref py-attr">create_uid</code></a>, <a href="#odoo.models.Model.create_date" class="internal reference" title="odoo.models.Model.create_date"><code class="py xref py-attr">create_date</code></a>, <a href="#odoo.models.Model.write_uid" class="internal reference" title="odoo.models.Model.write_uid"><code class="py xref py-attr">write_uid</code></a> и <a href="#odoo.models.Model.write_date" class="internal reference" title="odoo.models.Model.write_date"><code class="py xref py-attr">write_date</code></a>: они теперь создаются как обычные &quot;законные&quot; поля и могут читаться и записываться, как и любые другие</p></li><li ><p >когда прямое преобразование невозможно (семантика не может быть преобразована), или версия «старого API» нежелательна и может быть улучшена до нового API, можно использовать совершенно разные «старые API» и «новые API» для одного и того же имени метода, используя <code class="py xref py-func">v8()</code>. Метод должен быть сначала определен с использованием старого API и задекорирован <a href="#odoo.api.v7" class="internal reference" title="odoo.api.v7"><code class="py xref py-func">v7()</code></a>, затем он должен быть переопределен с использованием того же самого имени, но с новым API-интерфейсом и задекорирован <a href="#odoo.api.v8" class="internal reference" title="odoo.api.v8"><code class="py xref py-func">v8()</code></a>. Вызовы из старого API-интерфейса будут отправлены в первую реализацию, а вызовы из контекста нового API будут отправлены во вторую реализацию. Одна реализация может вызывать (и часто делает) оба вызова, переключая контекст.</p><div role="alert" class="alert-danger alert"><h3 class="alert-title">Опасно</h3><p >использование этих декораторов делает методы чрезвычайно трудными для переопределения их труднее понять и документировать</p></div></li><li ><p >использование  <code class="py xref py-attr">_columns</code> or <code class="py xref py-attr">_all_columns</code> следует заменить на by <code class="py xref py-attr">_fields</code>, которые предоставляют доступ экземплярам с новым API <a href="#odoo.fields.Field" class="internal reference" title="odoo.fields.Field"><code class="py xref py-class">odoo.fields.Field</code></a> (чаще чем <code class="py xref py-class">odoo.osv.fields._column</code>).</p><p >Не сохраненные вычисленные поля, созданные с использованием нового API, <em >недоступны</em> в <code class="py xref py-attr">_columns</code> и могут быть проверены только через <code class="py xref py-attr">_fields</code></p></li><li ><p >переназначение <code >self</code> в методе, вероятно, не нужно и может нарушить интроспекцию трансляции</p></li><li ><p ><code class="py xref py-class">manage</code> при попытке использовать новый API в контекстах, где он еще не был настроен, например, новые потоки или интерактивная среда Python:</p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">odoo</span> <span class="k">import</span> <span class="n">api</span><span class="p">,</span> <span class="n">modules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">modules</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">RegistryManager</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cr</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">Environment</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{})</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">environments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">api</span><span class="o">.</span><span class="n">Environment</span><span class="o">.</span><span class="n">manage</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">env</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">Environment</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{})</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">env</span><span class="p">[</span><span class="s1">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">res.partner(1,)</span>
</pre></div>
</div>
</li></ul></section><section id="automatic-bridging-of-old-api-methods"><i id="reference-orm-oldapi-bridging"></i><h3 >Автоматический проброс старых API-методов</h3><p >Когда модели инициализируются, все методы автоматически сканируются и пробрасываются, если они похожи на модели данных, объявленные в старом API. Этот проброс делает их прозрачно вызываемыми из методов нового API.</p><p >Методы сопоставляются как «старый-API», если их второй позиционный параметр (после <code >self</code>) называется <code >cr</code> или <code >cursor</code>. Система также распознает третий позиционный параметр, называемый <code >uid</code> или <code >user</code>, а четвертый называется <code >id</code> или <code >ids</code>. Он также распознает наличие любого параметра, вызываемого с помощью <code >context</code>.</p><p >При вызове таких методов из контекста нового API система автоматически заполнит согласованные параметры из текущего <code class="py xref py-class">Environment</code> (for <code class="py xref py-attr">cr</code>, <code class="py xref py-attr">user</code> and <code class="py xref py-attr">context</code>) или текущий НЗ (для <code >id</code> and <code >ids</code>).</p><p >В редких случаях, когда это необходимо, проброс можно настроить, задекорировав метод старого API:</p><ul ><li ><p >полностью отключить его, задекорировав метод с помощью <code class="py xref py-func">noguess()</code> не будет никакого проброса, и методы будут вызываться точно таким же образом из нового и старого API</p></li><li ><p >явным образом определяя проброс, это в основном подходит для методов, которые неправильно сопоставляются (потому что параметры названы непредвиденными способами):</p><dl ><dt ><code class="py xref py-func">cr()</code></dt><dd ><p >автоматически добавит текущий курсор к явно заданным параметрам, позиционно</p></dd><dt ><code class="py xref py-func">cr_uid()</code></dt><dd ><p >автоматически добавит текущий курсор и идентификатор пользователя к явно заданным параметрам</p></dd><dt ><code class="py xref py-func">cr_uid_ids()</code></dt><dd ><p >автоматически добавит текущий курсор, идентификатор пользователя и идентификаторы набора записей в явно заданные параметры</p></dd><dt ><code class="py xref py-func">cr_uid_id()</code></dt><dd ><p >будет выполнять перебор по текущему набору записей и вызывать метод один раз для каждой записи, добавляя к текущему курсору, идентификатору пользователя и идентификатору записи явно указанные параметры.</p><div role="alert" class="alert-danger alert"><h3 class="alert-title">Опасно</h3><p >результатом работы враппера является <em >всегда список</em> при вызове из контекста нового API</p></div></dd></dl><p >Все эти методы имеют версию <code >_context</code>-suffixed (например <code class="py xref py-func">cr_uid_context()</code>), которая также передает текущий контекст <em >по ключевому слову</em>.</p></li><li ><p >двойная реализация, использующая <a href="#odoo.api.v7" class="internal reference" title="odoo.api.v7"><code class="py xref py-func">v7()</code></a> и <a href="#odoo.api.v8" class="internal reference" title="odoo.api.v8"><code class="py xref py-func">v8()</code></a> будет игнорироваться, поскольку они предоставляют свои собственные &quot;пробросы&quot;</p></li></ul></section>

          </article>
        </div>
        
        <div id="mask"></div>
      </main>
  </div>

  <div class="floating_action_container">
    <a id="floating_action" class="ripple" href="#">
      <i class="mdi-action-explore"></i>
    </a>
    <div id="floating_action_menu">
      <span class="bubble"></span>
      <ul class="list-group content">
        <li class="list-group-item ripple"><a>Cras justo odio</a></li>
        <li class="list-group-item ripple"><a>Dapibus ac facilisis in</a></li>
        <li class="list-group-item ripple"><a>Morbi leo risus</a></li>
        <li class="list-group-item ripple"><a>Porta ac consectetur ac</a></li>
        <li class="list-group-item ripple"><a>Vestibulum at eros</a></li>
      </ul>
    </div>
  </div>
  <footer class="o_footer_effect">
      <div id="footer" class="container o_not_editable">
          <span class="o_logo o_logo_inverse center-block o_footer_logo"></span>
          <div class="row">
              <div class="col-xs-12">
                  <hr/>
                  <p>Перевод документации при поддержке <a href="https://www.yartsev.by/" target="_blank">Ярцев и компаньоны</a> и <a href="https://www.udelta.ru" target="_blank">Udelta</a></p>
                  <hr/>
                  <p>
                      <small>Odoo - это набор бизнес-приложений с открытым исходным кодом, которые охватывают все потребности вашей компании: CRM, интернет магазин, бухгалтерский учет, складской учет, POS терминал, управление проектами и т.д. <br/> <br/>
                      В то же время полноценное внедрение Odoo может быть очень простым и включать полную интеграцию с вашим предприятием.</small>
                  </p>
              </div>
          </div>
      </div>
  
      <div class="o_footer_bottom o_not_editable">
          <div class="container">
              <a class="small" href="https://www.odoo.com/page/website-builder">Website made with <span class="o_logo o_logo_inverse o_logo_15"></span></a>
              <div class="social-links pull-right">
                  <a href="https://www.odoo.com/web/about/facebook">
                      <i class="fa fa-facebook"></i>
                  </a>
                  <a href="https://www.odoo.com/web/about/twitter">
                      <i class="fa fa-twitter"></i>
                  </a>
                  <a href="https://www.odoo.com/web/about/linkedin">
                      <i class="fa fa-linkedin"></i>
                  </a>
                  <a href="mailto:info@odoo.com">
                      <i class="fa fa-envelope"></i>
                  </a>
              </div>
          </div>
      </div>
    </footer><!-- Yandex.Metrika counter --> <script type="text/javascript"> (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter44508703 = new Ya.Metrika({ id:44508703, clickmap:true, trackLinks:true, accurateTrackBounce:true, webvisor:true }); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = "https://mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks"); </script> <noscript><div><img src="https://mc.yandex.ru/watch/44508703" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter -->
  </body>
</html>